<!doctype html><html lang=de-de><head><title>DSLs, Extension Methods und Fluent Interfaces // Blog von Alexander Köpke</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Alexander Köpke"><meta name=description content><link rel=stylesheet href=/blog/css/main.min.ead1f6492242b7d93618e6840b25260f8ea1ca68dc04cc9cf1b88adcb996693b.css><meta name=twitter:card content="summary"><meta name=twitter:title content="DSLs, Extension Methods und Fluent Interfaces"><meta name=twitter:description content="In den letzten Jahren wurde in der Softwareentwicklung viel über Domänenspezifische Sprachen (domain specific language, kurz: DSLs) geschrieben. DSLs sollen von einem Domänenexperten gelesen werden können, auch ohne das die Domänenexperten über Programmierkenntnisse verfügen. DSLs können auch Entwicklern helfen die Quelltexte leserlicher zu machen, sowie Fehler zu vermeiden. Die Quelltextzeile:
if (!SessionEstablished)
Ist einfach verständlich (für diejenigen welche eine C ähnliche Syntax verstehen), als Alternative könnte folgende Quelltextzeile dienen:
if (Not(SessionEstablished))"><meta property="og:title" content="DSLs, Extension Methods und Fluent Interfaces"><meta property="og:description" content="In den letzten Jahren wurde in der Softwareentwicklung viel über Domänenspezifische Sprachen (domain specific language, kurz: DSLs) geschrieben. DSLs sollen von einem Domänenexperten gelesen werden können, auch ohne das die Domänenexperten über Programmierkenntnisse verfügen. DSLs können auch Entwicklern helfen die Quelltexte leserlicher zu machen, sowie Fehler zu vermeiden. Die Quelltextzeile:
if (!SessionEstablished)
Ist einfach verständlich (für diejenigen welche eine C ähnliche Syntax verstehen), als Alternative könnte folgende Quelltextzeile dienen:
if (Not(SessionEstablished))"><meta property="og:type" content="article"><meta property="og:url" content="https://koepalex.github.io/blog/blog/2012-07-28-dsls-extension-methods-und-fluent-interfaces/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2012-07-28T00:00:00+00:00"><meta property="article:modified_time" content="2012-07-28T00:00:00+00:00"></head><body><header class=app-header><a href=https://koepalex.github.io/blog/><img class=app-header-avatar src=/blog/avatar.jpg alt="Alexander Köpke"></a>
<span class=app-header-title>Blog von Alexander Köpke</span><p>Technischer Artikel, das Universum und der ganze Rest</p><div class=app-header-social><a href=https://github.com/koepalex target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/koepalex target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>DSLs, Extension Methods und Fluent Interfaces</h1><div class=post-meta><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Jul 28, 2012</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>3 min read</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://koepalex.github.io/blog/tags/dsl/>dsl</a>
<a class=tag href=https://koepalex.github.io/blog/tags/extension-methods/>extension-methods</a>
<a class=tag href=https://koepalex.github.io/blog/tags/fluent-interfaces/>fluent-interfaces</a></div></div></header><div class=post-content><p>In den letzten Jahren wurde in der Softwareentwicklung viel über Domänenspezifische Sprachen (domain specific language, kurz: DSLs) geschrieben. DSLs sollen von einem Domänenexperten gelesen werden können, auch ohne das die Domänenexperten über Programmierkenntnisse verfügen. DSLs können auch Entwicklern helfen die Quelltexte leserlicher zu machen, sowie Fehler zu vermeiden. Die Quelltextzeile:</p><blockquote><p>if (!SessionEstablished)</p></blockquote><p>Ist einfach verständlich (für diejenigen welche eine C ähnliche Syntax verstehen), als Alternative könnte folgende Quelltextzeile dienen:</p><blockquote><p>if (Not(SessionEstablished))</p></blockquote><p>Die relevante Information, dass es darum geht, herauszufinden, ob eine Verbindung nicht aufgebaut ist, sticht deutlicher heraus. Zudem erleichtert die textuelle Beschreibung das Verständnis, man muss zum Verstehen nicht wissen das „!“ die Negation der folgenden Anweisung bedeutet.</p><p>Eine einfache Möglichkeit eine DSL mit C# .NET zu realisieren sind Erweiterungsmethoden (extension methods), als Beispiel diene eine Klasse, welche Relationen (Links) zwischen zwei Objekten (wie Datenbankentitäten) darstellt.</p><blockquote><p>public class Relation : IRelation<br>{<br>   //&mldr;<br>   public DomainObject Target {get; private set; }<br>   public DomainObject Source {get; private set; }<br>   public static IEnumerable GetAllRelations   (DomainObject source) {/* …*/ }<br>   //&mldr;<br>}</p></blockquote><p>Um zu wissen, ob ein DomainObject mit einem anderen verlinkt ist, ist die Implementierung einfach:<br>if (Relation.GetAllRelations(obj).Any(rel => rel.Target == otherObject))</p><p>Für Entwickler, die keine LINQ-Anweisungen verstehen, ist der Quelltext jedoch nicht so einfach. Eine Extension Method, könnte in diesem Fall sehr zur Verständlichkeit beitragen.</p><blockquote><p>public static class ExtensionMethods<br>{<br>    public bool IsLinkedTo<br>       (this DomainObject source, DomainObject target)<br>   {<br>      return Relation.GetAllRelations(source).Any(<br>             rel =>  rel.Target    == target);<br>   }<br>}</p></blockquote><p>Mit dieser Extension Methode sieht man das der Quelltext der Ursprünglichen vereinfacht wurde:</p><blockquote><p>if (obj.IsLinkedTo(otherObject))</p></blockquote><p>Eine andere Möglichkeit um eine DSL zu realisieren sind Fluent Interfaces. Die Idee ist, dass der Aufruf einer Methode, ein Interface zurückliefert, an diesem können dann sofort weitere Methoden aufgerufen werden. Dadurch ergibt sich eine Art „Satz“ der schnell erfasst werden kann (und dies ohne if (foo != null) Kaskaden alias Weihnachtsbäume).</p><p>In dem wegweisenden Buch von Robert C Martin (Clean Code, Seite 235ff), wird sehr schön beschrieben, wie ein Commandline-Parser refaktorisiert wurde, damit dieser einfacher zu verstehen, zu warten, zu erweitern und zu testen ist. Das einzige was beim Verwender der Klasse Args von Robert C Martin stört, ist, dass man die Typen der Parameter nicht erkennen kann:<br>Dazu erst einmal der originale Aufruf der Klasse:</p><blockquote><p>Args arg = new Args(&ldquo;l, p#, d*&rdquo;, args);</p></blockquote><p>Oder können sie erkennen, welchen Typen die Parameter &ldquo;l&rdquo;, &ldquo;p&rdquo; und &ldquo;d&rdquo; besitzen? Nicht ohne zu wissen, was &ldquo;*&rdquo; oder &ldquo;#&rdquo; in diesem Kontext bedeutet. Dazu muss der Leser der Methode, in die Dokumentation oder in den Quelltext schauen.</p><p>Eine Fluent Interface Variante könnte wie folgt aussehen:</p><blockquote><p>Args arg = Args.GetInstance()<br>     .Argument(&ldquo;l&rdquo;).SetDefault(false)<br>     .Argument(&ldquo;p&rdquo;).SetDefault(42)<br>     .Argument(&ldquo;d&rdquo;).SetDefault(&ldquo;foo&rdquo;)<br>     .Parse(args);</p></blockquote><p>Diese Variante ist nicht so kompakt wie die ursprüngliche, dafür enthält sie mehr Informationen (über Typen und Defaultwerte). Die Mächtigkeit zeigen Fluent Interfaces, wenn es darum geht, bestehenden Implementierungen zu erweitern. Egal ob man alle Parameter über ein anderes Zeichen beginnen lassen möchte &ldquo;-&rdquo;, &ldquo;&ndash;&rdquo;, &ldquo;/&rdquo;, ob man zusätzliche Hilfe Texte zu den Parametern hinterlegen, ob man eine Validierung (über Minimal- und Maximalwerte) hinzufügen oder eine Aktion auslösen möchte.</p><blockquote><p>Args arg = Args.GetInstance()<br>.SetParameterSymbol("—")<br>   .Argument(&ldquo;l&rdquo;)<br>      .SetDefault(false)<br>      .AddDescription()<br>         .Header(&ldquo;l means Log&rdquo;)<br>         .Text(&ldquo;starting the programm with a verbose logging&rdquo;)<br>         .SetAction()<br>            .WhenValueEqualsTo(true)<br>            .Do (() => {m_Logger = new VerboseLogger();})<br>   .Argument(&ldquo;p&rdquo;)<br>      .SetDefault(23)<br>      .AddValidation()<br>         .Minimum(7)<br>         .Maximum(42)<br>         .SetAction()<br>            .WhenValueOutsideRange()<br>            .Do((val) =><br>            {<br>                Console.WriteLine(Ressource.ErrorCountProcesses);<br>                m_NumberOfProcesses = 23;<br>           })<br>           .OtherwiseDo((val) =><br>          {<br>             m_NumberOfProcesses = val;<br>          })<br>   .Argument(&ldquo;d&rdquo;)<br>       .SetDefault(&ldquo;foo&rdquo;)<br>.Parse(args);</p></blockquote><p>Das letzte Beispiel enthält sehr viel Logik, entscheiden sie selbst ob sie es nicht vielleicht trotzdem als einfach verständlich betrachten.</p></div><div class=post-footer></div></article></main></body></html>