<!doctype html><html lang=de-de><head><title>Ermitteln des PID (Processidentifier) des Vaterprozesses // Blog von Alexander Köpke</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Alexander Köpke"><meta name=description content><link rel=stylesheet href=/blog/css/main.min.3c3c186cd62e563ad6e2f00a89dbee656ab912d1d46f856b5605dd0232521e2a.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Ermitteln des PID (Processidentifier) des Vaterprozesses"><meta name=twitter:description content="In manchen Fällen ist es notwendig heraus zu finden, welches der Vaterprozess eines Prozesses ist. Dafür gibt es im Allgemeinen drei verschiedene Lösungen im Windows .NET Umfeld.
Die häufigste Lösung ist die Verwendung von Performancecountern.
var process = FindProcess();
using (var pC = new PerformanceCounter(
&ldquo;Process&rdquo;,
&ldquo;Creating Process ID&rdquo;,
string.Format(&#34;{0}#{1}&#34;, process.ProcessName, 1), process.MachineName))
{
int pid = (int)pC.NextValue();
Console.WriteLine(&ldquo;parent pid = {0}&rdquo;, pid);
}
Die Verwendung von Performancecountern im Allgemeinen kann zwei mögliche Nachteile haben:"><meta property="og:title" content="Ermitteln des PID (Processidentifier) des Vaterprozesses"><meta property="og:description" content="In manchen Fällen ist es notwendig heraus zu finden, welches der Vaterprozess eines Prozesses ist. Dafür gibt es im Allgemeinen drei verschiedene Lösungen im Windows .NET Umfeld.
Die häufigste Lösung ist die Verwendung von Performancecountern.
var process = FindProcess();
using (var pC = new PerformanceCounter(
&ldquo;Process&rdquo;,
&ldquo;Creating Process ID&rdquo;,
string.Format(&#34;{0}#{1}&#34;, process.ProcessName, 1), process.MachineName))
{
int pid = (int)pC.NextValue();
Console.WriteLine(&ldquo;parent pid = {0}&rdquo;, pid);
}
Die Verwendung von Performancecountern im Allgemeinen kann zwei mögliche Nachteile haben:"><meta property="og:type" content="article"><meta property="og:url" content="https://koepalex.github.io/blog/blog/2012-10-14-ermitteln-des-pid-processidentifier-des-vaterprozesses/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2012-10-14T00:00:00+00:00"><meta property="article:modified_time" content="2012-10-14T00:00:00+00:00"></head><body><header class=app-header><a href=https://koepalex.github.io/blog/><img class=app-header-avatar src=/blog/avatar.jpg alt="Alexander Köpke"></a>
<span class=app-header-title>Blog von Alexander Köpke</span><p>Technischer Artikel, das Universum und der ganze Rest</p><div class=app-header-social><a href=https://github.com/koepalex target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/koepalex target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Ermitteln des PID (Processidentifier) des Vaterprozesses</h1><div class=post-meta><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Oct 14, 2012</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>2 min read</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://koepalex.github.io/blog/tags/ntdll/>ntdll</a>
<a class=tag href=https://koepalex.github.io/blog/tags/parent/>parent</a>
<a class=tag href=https://koepalex.github.io/blog/tags/performancecounter/>performancecounter</a>
<a class=tag href=https://koepalex.github.io/blog/tags/pid/>pid</a>
<a class=tag href=https://koepalex.github.io/blog/tags/wmi/>wmi</a></div></div></header><div class=post-content><p>In manchen Fällen ist es notwendig heraus zu finden, welches der Vaterprozess eines Prozesses ist. Dafür gibt es im Allgemeinen drei verschiedene Lösungen im Windows .NET Umfeld.</p><p>Die häufigste Lösung ist die Verwendung von <strong>Performancecountern</strong>.</p><blockquote><p>var process = FindProcess();<br>using (var pC = new PerformanceCounter(</p><p>    &ldquo;Process&rdquo;,<br>    &ldquo;Creating Process ID&rdquo;,<br>    string.Format("{0}#{1}", process.ProcessName, 1),  <br>    process.MachineName))<br>{<br>       int pid = (int)pC.NextValue();<br>       Console.WriteLine(&ldquo;parent pid = {0}&rdquo;, pid);<br>}</p></blockquote><p>Die Verwendung von Performancecountern im Allgemeinen kann zwei mögliche Nachteile haben:</p><ol><li>Vor Windows Vista war es ausreichend, dass der Account des Benutzers lokale Administratorrechte besitzt, um Performancecounter zu nutzen. Seit Windows Vista, muss der Account zusätzlich Mitglied in der Gruppe &ldquo;Performance Monitor Users&rdquo; sein oder der Programmierer muss mittels UAC (User Account Control) zur Laufzeit die entsprechenden Rechte beantragen.</li><li>Performancecounter funktionieren im wesentlichen dadurch, dass ihre Werte über die Registry abgefragt werden können. Auch werden alle Performancecounter über die Registry bekannt gegeben, somit ist eine Nutzung aus unterschiedlichen Programmen möglich (vgl. <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa371643%28v=vs.85%29.aspx">http://msdn.microsoft.com/en-us/library/windows/desktop/aa371643(v=vs.85).aspx</a>). Die Registry kann in verschiedenen Fällen jedoch korrumpiert werden, dies führt zu einer &ldquo;System.FormatException&rdquo; beim anlegen eines Performancecounters.  Es ist natürlich ohne weiteres Möglich die Exception zu fangen, jedoch wird man den Wert des Performancecounters nicht bekommen. Auf der Microsoft Support Webseite findet sich eine Anleitung um die Registry manuell zu reparieren (<a href=http://support.microsoft.com/kb/300956>http://support.microsoft.com/kb/300956</a>).</li></ol><p>Eine zweite Lösung ist mittels <strong>P/Invoke die Windows Systembibliothek &ldquo;ntdll.dll&rdquo;</strong> anzusprechen. Über die Methode NtQueryInformationProcess kann man Zugriff auf ein PROCESS_BASIC_INFORMATION-Struktur erlangen. Das Element InheritedFromUniqueProcessId liefert anschließend die gewünschte PID. Eine Beispielimplementierung ist zu finden unter <a href=http://www.pinvoke.net/default.aspx/ntdll.ntqueryinformationprocess>http://www.pinvoke.net/default.aspx/ntdll.ntqueryinformationprocess</a>.</p><p>Von der Verwendung der Methode ist jedoch aus heutiger Sicht abzuraten, da Microsoft im entsprechenden Developer Network Artikel darauf hinweist, dass diese in Zukunft modifiziert oder nicht mehr verfügbar sein wird (vgl. <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684280(v=vs.85).aspx">http://msdn.microsoft.com/en-us/library/windows/desktop/ms684280(v=vs.85).aspx</a>).</p><p>Die (von mir) empfohlene Variante ist die Verwendung der <strong>Windows Management Instrumentation</strong> (kurz WMI, vgl. <a href="http://msdn.microsoft.com/en-us/library/aa384642(v=vs.85).aspx">http://msdn.microsoft.com/en-us/library/aa384642(v=vs.85).aspx</a>). Es handelt sich hierbei um eine Implementierung der Web Based Enterprise Management-Spezifikation. Die Spezifikation enthält eine Menge von Funktionen zum Administrieren und zur Fernwartung von Computern, wobei sie Hardware und Betriebssystem unabhängig ist. WMI lässt sich auch lokal auf dem Computer verwenden, das auslesen der PID des Vaterprozesses sieht wie folgt aus:</p><blockquote><p>var process = FindProcess();<br>var query = string.Format(&ldquo;SELECT ParentProcessId FROM Win32_Process WHERE ProcessId = {0}&rdquo;, process.Id);<br>using (var mos = new ManagementObjectSearcher(query))<br>{<br>    var enumerator = mos.Get().GetEnumerator();<br>    if(enumerator.MoveNext())<br>    {<br>        int pid = (int)((uint)enumerator.Current  <br>           [&ldquo;ParentProcessId&rdquo;]);<br>        Console.WriteLine(&ldquo;parent pid = {0}&rdquo;, pid);<br>    }<br>    else<br>        throw new InvalidOperationException(&ldquo;can&rsquo;t read <br>           parentProcessId by WMI&rdquo;);<br>}</p></blockquote></div><div class=post-footer></div></article></main></body></html>