<!doctype html><html lang=de-de><head><title>Debugging von Performance Problemen in .NET // Blog von Alexander Köpke</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Alexander Köpke"><meta name=description content><link rel=stylesheet href=/blog/css/main.min.3c3c186cd62e563ad6e2f00a89dbee656ab912d1d46f856b5605dd0232521e2a.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Debugging von Performance Problemen in .NET"><meta name=twitter:description content="Die Analyse von Speicherproblemen ist eine Aufgabe die bei großen .NET Anwendungen häufiger vorkommt. In C++ wurde gesucht, wer welche Speicherblöcke angefordert und nicht wieder freigegeben hat und im .NET Umfeld wird eben gesucht warum der Gabarge-Collector den Speicher nicht freigeben kann. Oder man sucht warum einige Benutzeraktionen besonders lange benötigen. Für die Analyse gibt es eine ganze Reihe guter kommerzieller Programme, auf diese möchte ich jedoch nicht eingehen, sondern ein paar kostenlosen Alternativen vorstellen."><meta property="og:title" content="Debugging von Performance Problemen in .NET"><meta property="og:description" content="Die Analyse von Speicherproblemen ist eine Aufgabe die bei großen .NET Anwendungen häufiger vorkommt. In C++ wurde gesucht, wer welche Speicherblöcke angefordert und nicht wieder freigegeben hat und im .NET Umfeld wird eben gesucht warum der Gabarge-Collector den Speicher nicht freigeben kann. Oder man sucht warum einige Benutzeraktionen besonders lange benötigen. Für die Analyse gibt es eine ganze Reihe guter kommerzieller Programme, auf diese möchte ich jedoch nicht eingehen, sondern ein paar kostenlosen Alternativen vorstellen."><meta property="og:type" content="article"><meta property="og:url" content="https://koepalex.github.io/blog/blog/2013-11-27-debugging-von-performance-problemen-in-net/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2013-11-27T00:00:00+00:00"><meta property="article:modified_time" content="2013-11-27T00:00:00+00:00"></head><body><header class=app-header><a href=https://koepalex.github.io/blog/><img class=app-header-avatar src=/blog/avatar.jpg alt="Alexander Köpke"></a>
<span class=app-header-title>Blog von Alexander Köpke</span><p>Technischer Artikel, das Universum und der ganze Rest</p><div class=app-header-social><a href=https://github.com/koepalex target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/koepalex target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Debugging von Performance Problemen in .NET</h1><div class=post-meta><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Nov 27, 2013</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>3 min read</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://koepalex.github.io/blog/tags/perfvew/>perfvew</a>
<a class=tag href=https://koepalex.github.io/blog/tags/sos/>sos</a>
<a class=tag href=https://koepalex.github.io/blog/tags/sosex/>sosex</a>
<a class=tag href=https://koepalex.github.io/blog/tags/windbg/>windbg</a></div></div></header><div class=post-content><p>Die Analyse von Speicherproblemen ist eine Aufgabe die bei großen .NET Anwendungen häufiger vorkommt. In C++ wurde gesucht, wer welche Speicherblöcke angefordert und nicht wieder freigegeben hat und im .NET Umfeld wird eben gesucht warum der Gabarge-Collector den Speicher nicht freigeben kann. Oder man sucht warum einige Benutzeraktionen besonders lange benötigen. Für die Analyse gibt es eine ganze Reihe guter kommerzieller Programme, auf diese möchte ich jedoch nicht eingehen, sondern ein paar kostenlosen Alternativen vorstellen.</p><h3 id=perfviewhttpwwwmicrosoftcomen-usdownloaddetailsaspxid28567><a href="http://www.microsoft.com/en-us/download/details.aspx?id=28567">PerfView</a></h3><p>Dieses Programm von Microsoft ist klein, schnell und leistungsfähig. Zum einen bietet es die Möglichkeit mittels ETW (Event Tracing for Windows) Problemen in der Laufzeit (CPU, I/O, GC) auf die Spur zu kommen. Zum anderen kann es Speicherabbilder von Programmen erzeugen und diese <strong>Vergleichen</strong>! Ausführliche Informationen gibt es bei <a href=http://channel9.msdn.com/Series/PerfView-Tutorial>Channel9</a> oder auf <a href=http://blogs.msdn.com/b/vancem/>Vance Morrison’s Webblog</a>.</p><h3 id=windbghttpmsdnmicrosoftcomen-uslibrarywindowshardwareff551063aspx-mit-_s_on-_o_f-_s_trikes-erweiterung><a href=http://msdn.microsoft.com/en-us/library/windows/hardware/ff551063.aspx>WinDbg</a> mit „_S_on _O_f _S_trikes“ Erweiterung</h3><p>Microsoft liefert die sos.dll mit dem .NET Framework aus. Sie ermöglicht den WinDbg dazu managed Code zu debuggen. Für die den Themenkomplex <em>WinDbg und SOS</em>, gibt es viele gute Artikel/Tutorials von welchen ich zwei empfehlen möchte:</p><ol><li>Der Blog von <a href="http://blogs.msdn.com/b/tess/default.aspx?PageIndex=1&amp;PostSortBy=MostRecent">Tess Ferrandez</a> beispielsweise mit den Artikeln „<a href=http://blogs.msdn.com/b/tess/archive/2007/10/19/net-finalizer-memory-leak-debugging-with-sos-dll-in-visual-studio.aspx>.NET Finalizer Memory Leak</a>“ und „<a href="http://blogs.msdn.com/b/tess/archive/2010/03/01/new-commands-in-sos-for-net-4-0-part-1.aspx?Redirected=true">New commands in SOS for 4.0</a>“.</li><li>Ein <a href=http://blogs.msdn.com/b/rextang/archive/2007/07/24/4026494.aspx>Blogeintrag von Rex Tang</a> in welchem er weitere lesenswerte Artikel zu diesem Thema auflistet.</li></ol><p>Auf der MSDN Webseite befindet sich die <a href=http://msdn.microsoft.com/de-de/library/bb190764.aspx>Befehlsreferenz</a>.</p><h3 id=windbg-mit-_sos-ex_tensionhttpwwwstevestechspotcom-erweiterung>WinDbg mit „<a href=http://www.stevestechspot.com>_SOS EX_tension</a>“ Erweiterung</h3><p>Die von Steve Johnson geschriebene sosex.dll bietet viele nützliche Erweiterungen die dass managed Code debugging im WinDbg deutlich vereinfachen. Beispielsweise kann die SOSEX mittels Befehl <code>!bhi</code> einen HeapIndex erstellen lassen. Dieser Index enthält alle benötigten Informationen über die Objekte auf dem Heap. Um anschließend z.B. alle GC-Roots eines Objektes zu finden (<code>!mroot &lt;adr> -all</code>) muss die SOSEX nicht das gesamte Speicherabbild analysieren sondern nur den HeapIndex. Dieses Vorgehen funktioniert deutlich schneller als die Alternative der SOS (<code>!gcroot -all &lt;adr></code>), welche jedes mal das Speicherabbild durchsucht.</p><p>Eine andere Eigenschaft ist das die SOSEX <a href=http://www.wintellect.com/blogs/jrobbins/a-cool-windbg-sos-hidden-feature>.prefer_dml 1</a> verwendet d.h. dass Links in die Ausgabe des WinDbg eingebettet werden. Dadurch wird einem häufig das kopieren bzw. abtippen von teilen der Ausgabe erspart.</p><p>Weitere Funktionalitäten der SOSEX sind</p><ul><li>Anzeige von managed Locks und native CriticalSections (<code>!mlocks</code>)</li><li>Anzeige von wartenden Thread inkl. dem worauf sie warten (<code>!mwaits</code>)</li><li>Anzeige von Objekten in der Finalizer Queue (<code>!finq</code>)</li><li>Anzeige von Objekten in der F-Reachable Queue (<code>!frq</code>)</li></ul><p><em>Lesen sie <a href=http://blogs.microsoft.co.il/sasha/2012/07/28/finalization-queue-or-f-reachable-queue-sosex-not-so-new-commands/>hier</a> die Beschreibung des Unterschiedes zwischen Finalizer Queue und F-Reachable Quere.</em></p><p>Tip: Herr Johnson aktualisiert SOSEX regelmäßig, auch wenn er dazu keine Notiz auf seinen Blog hinterlässt. Deshalb lohnt es sich immer mal wieder das Zip-Archiv herunter zuladen und zu prüfen ob die enthaltene SOSEX neuer ist als die eigene.</p></div><div class=post-footer></div></article></main></body></html>