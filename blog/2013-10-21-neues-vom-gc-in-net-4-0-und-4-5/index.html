<!doctype html><html lang=de-de><head><title>Neues vom GC in .NET 4.0 und 4.5 // Blog von Alexander Köpke</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Alexander Köpke"><meta name=description content><link rel=stylesheet href=/blog/css/main.min.ead1f6492242b7d93618e6840b25260f8ea1ca68dc04cc9cf1b88adcb996693b.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Neues vom GC in .NET 4.0 und 4.5"><meta name=twitter:description content="Heute möchte ich etwas über Erneuerungen im .NET 4.0 / 4.5 sprechen. Das genannte bezieht sich auf den Workstation Garbage-Collector. Die Informationen für den Server Garbage-Collector entnehmen sie bitte den Links. Beginnen wir jedoch zunächst mit einer kurzen Auffrischung.
Wiederholung Das .NET Framework unterteilt seinen Heap in verschiedene Generationen.
In der Gen0 werden fast alle Objekte erstellt. Die Anfangsgröße beträgt rund 256KB. In der Gen1 werden Objekte gespeichert die eine Garbage-Collection überlebt haben."><meta property="og:title" content="Neues vom GC in .NET 4.0 und 4.5"><meta property="og:description" content="Heute möchte ich etwas über Erneuerungen im .NET 4.0 / 4.5 sprechen. Das genannte bezieht sich auf den Workstation Garbage-Collector. Die Informationen für den Server Garbage-Collector entnehmen sie bitte den Links. Beginnen wir jedoch zunächst mit einer kurzen Auffrischung.
Wiederholung Das .NET Framework unterteilt seinen Heap in verschiedene Generationen.
In der Gen0 werden fast alle Objekte erstellt. Die Anfangsgröße beträgt rund 256KB. In der Gen1 werden Objekte gespeichert die eine Garbage-Collection überlebt haben."><meta property="og:type" content="article"><meta property="og:url" content="https://koepalex.github.io/blog/blog/2013-10-21-neues-vom-gc-in-net-4-0-und-4-5/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2013-10-21T00:00:00+00:00"><meta property="article:modified_time" content="2013-10-21T00:00:00+00:00"></head><body><header class=app-header><a href=https://koepalex.github.io/blog/><img class=app-header-avatar src=/blog/avatar.jpg alt="Alexander Köpke"></a>
<span class=app-header-title>Blog von Alexander Köpke</span><p>Technischer Artikel, das Universum und der ganze Rest</p><div class=app-header-social><a href=https://github.com/koepalex target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/koepalex target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Neues vom GC in .NET 4.0 und 4.5</h1><div class=post-meta><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Oct 21, 2013</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>4 min read</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://koepalex.github.io/blog/tags/gc/>gc</a>
<a class=tag href=https://koepalex.github.io/blog/tags/largeobjectheapcompactionmode/>largeobjectheapcompactionmode</a>
<a class=tag href=https://koepalex.github.io/blog/tags/loh/>loh</a>
<a class=tag href=https://koepalex.github.io/blog/tags/lowlatency/>lowlatency</a>
<a class=tag href=https://koepalex.github.io/blog/tags/soh/>soh</a>
<a class=tag href=https://koepalex.github.io/blog/tags/sustainedlowlatency/>sustainedlowlatency</a></div></div></header><div class=post-content><p>Heute möchte ich etwas über Erneuerungen im .NET 4.0 / 4.5 sprechen. Das genannte bezieht sich auf den Workstation Garbage-Collector. Die Informationen für den Server Garbage-Collector entnehmen sie bitte den Links. Beginnen wir jedoch zunächst mit einer kurzen Auffrischung.</p><h3 id=wiederholung>Wiederholung</h3><p>Das .NET Framework unterteilt seinen Heap in verschiedene Generationen.</p><ul><li>In der <strong>Gen0</strong> werden fast alle Objekte erstellt. Die Anfangsgröße beträgt rund 256KB.</li><li>In der <strong>Gen1</strong> werden Objekte gespeichert die <em>eine</em> Garbage-Collection überlebt haben. Die Anfangsgröße beträgt rund 2 MB.</li><li>In der <strong>Gen2</strong> werden Objekte gespeichert die <em>mehr als eine</em> Garbage-Collection überlebt haben Die Anfangsgröße beträgt 10 MB.</li></ul><p>Die soeben genannten Anfangsgrößen können zur Laufzeit variiert werden. Am stärksten wird sich i.A. die Größe der Gen2 verändern (wachsen), da die Gen2 als <em>Endlager</em> für alle länger benötigten Objekte dient.</p><p>Die Gen2 teilt sich logisch in zwei Bereiche auf:</p><ul><li><strong>SOH</strong> der <em>Small Object Heap</em> dieser enthält alle Objekte die durch mindestens zwei Garbage-Collections hierher verschoben wurden.</li><li><strong>LOH</strong> der <em>Large Object Heap</em> welcher alle Objekte mit einer Größe größer gleich 85 KB enthält.</li></ul><p>Eine Garbage-Collection läuft in zwei Schritten ab. Die erste Phase <em>Mark</em> markiert alle Objekte die nicht mehr benötigt werden. Im zweiten Schritt <em>Sweep</em> wird der Speicher der markierten Objekte freigegeben. Um zu entscheiden, ob ein Objekt noch benötigt wird, sucht der GC Wurzeln <em>Roots</em>. Wurzeln können u.a. statische Felder, Methodenparameter, lokale Variablen oder CPU Register sein. Hat ein Objekt (oder eine Gruppe von Objekten) keinen Verweis auf eine Wurzel ist es aus dem Programmcode nicht mehr zugreifbar und kann aus dem Speicher entfernt werden. Sollte ein Objekt eine Garbage-Collection überleben und noch nicht in Gen2 sein, wird es um eine Generation verschoben.</p><p>Zu einer Fragmentierung der 0. und 1. Generation kann es bei diesem Entwurf nicht kommen. Denn ein Objekt wird entweder verschoben (von 0 nach 1 bzw. von 1 nach 2) oder gelöscht.</p><p>Der SOH (der Gen2) kann über die Zeit fragmentieren, deswegen wird in der Sweep-Phase der Heap zusammen gepackt (komprimiert/defragmentiert). Für eine solche Garbage-Collection wird der Main-Thread vom Garbage-Collector-Thread unterbrochen. <strong>Der LOH kann über die Zeit auch fragmentieren hier wird jedoch keine Defragmentierung durchgeführt.</strong> Das kann zu Speicherknappheit (OutOfMemory-Abstürzen) in .NET Programmen führen, obwohl insgesamt genügend freier Speicher vorhanden ist.</p><h3 id=net-40>.NET 4.0</h3><p>Die Gen0 und Gen1 arbeitet der Garbage-Collector unverändert ab. Die Gen2-Collection läuft jetzt jedoch meist im Hintergrund. Diese <strong>nicht blockierende Garbage-Collection</strong> hat die Einschränkung, dass der SOH dabei nicht defragmentiert wird. Für eine Defragmentierung ist eine blockierende Garbage-Collection notwendig. Die Zeit in welcher die Garbage-Collection ein Programm blockiert wurde dadurch drastisch reduziert. <a href=http://msdn.microsoft.com/en-US/library/ee787088.aspx>Mehr zur Hintergrund Garbage-Collection</a></p><hr><p>Eine weitere Optimierung stellt der <strong>LowLatency</strong> Modus dar, dieser unterbindet jegliche Gen2-Collection <em>komplett</em>. Nur eine <em>low memory</em> Notifikation des Betriebssystems oder ein expliziter Aufruf von GC.Collect mit 2 als Parameter haben eine Gen2-Collection zur Folge. Das aktivieren des LowLatency-Modus ist nur für besonders Zeitkritische Aufgaben zu empfehlen und sollte deshalb nur vorübergehend genutzt werden. Aktiviert wurde der neue Modus mittels:</p><p><code>GCSettings.LatencyMode = GCLatencyMode.LowLatency;</code></p><p><a href=http://msdn.microsoft.com/en-us/library/bb384202.aspx>Weiterführende Dokumentation zum LowLatency Mode</a></p><h3 id=net-45>.NET 4.5</h3><p>Der Latency-Modus wurde um die Option <strong>SustainedLowLatency</strong> erweitert, welche im Gegensatz zum <em>LowLatency</em> zusätzliche Hintergrund Gen2-Collections durchführt. Der neue Modus ist dazu geeignet das Programm über einen längeren Zeitraum im LowLatency laufen zulassen. Der SustainedLowLatency Modus wurde übrigens von Microsoft auf für .NET 4.0 mit dem <a href=http://support.microsoft.com/kb/2600211>Update 3</a> nachgeliefert.</p><hr><p>Das Garbage-Collector-Team hat auch etwas für den LOH getan unter anderem das finden von freien Speicherblöcken bei einer Allokation verbessert:</p><blockquote><p>In preparation for LOH allocation requests, the GC builds up a list of free (available) memory blocks after a collection. As part of an allocation, the GC consults this these free memory blocks one by one to determine if any block in the list will satisfy the allocation. If a given memory block is a candidate, it is used for the allocation. In earlier releases of the .NET Framework, once a memory block was rejected as a candidate for an allocation, it was removed as a candidate for subsequent allocations.</p></blockquote><hr><p>Den größten Nutzen werden große Programme wohl davon haben, dass es jetzt möglich ist den <strong><em>LOH zu Komprimieren</em></strong>! Dazu ist nur folgender Quelltext notwendig:</p><p><code>GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce; //force Gen0 to Gen2 blocking GC GC.Collect();</code></p><hr><p>Für weitere Verbesserungen des wie <strong>Allokation von Objekten über 2 GB</strong> siehe <a href=http://blogs.msdn.com/b/dotnet/archive/2012/07/20/the-net-framework-4-5-includes-new-garbage-collector-enhancements-for-client-and-server-apps.aspx>The .NET Framework 4.5 includes new garbage collector enhancements for client and server apps</a>.</p></div><div class=post-footer></div></article></main></body></html>