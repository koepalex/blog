<!doctype html><html lang=de-de><head><title>FxCop Dispose von lokalen Variablen // Blog von Alexander Köpke</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Alexander Köpke"><meta name=description content><link rel=stylesheet href=/blog/css/main.min.ead1f6492242b7d93618e6840b25260f8ea1ca68dc04cc9cf1b88adcb996693b.css><meta name=twitter:card content="summary"><meta name=twitter:title content="FxCop Dispose von lokalen Variablen"><meta name=twitter:description content="Die Freigabe von Ressourcen (verwaltet und nativ) wird im .Net mittels Implementierung der IDisposable Schnittstelle (bzw. Anwendung des IDisposable Patterns realisiert). Der Aufruf der Dispose-Methode ist so wichtig, dass Microsoft spezielle FxCop Regeln implementiert hat (FxCop ist ein Tool zur statischen Analyse von .Net Assemblys). Die Regel „Disposable fields should be disposed“ (CA2213) besagt, dass eine Klasse welche Member enthält, die IDisposable implementieren, selber IDisposable implementieren soll. In der eigenen Dispose-Methode, werden dann die Dispose-Methoden der Members aufgerufen."><meta property="og:title" content="FxCop Dispose von lokalen Variablen"><meta property="og:description" content="Die Freigabe von Ressourcen (verwaltet und nativ) wird im .Net mittels Implementierung der IDisposable Schnittstelle (bzw. Anwendung des IDisposable Patterns realisiert). Der Aufruf der Dispose-Methode ist so wichtig, dass Microsoft spezielle FxCop Regeln implementiert hat (FxCop ist ein Tool zur statischen Analyse von .Net Assemblys). Die Regel „Disposable fields should be disposed“ (CA2213) besagt, dass eine Klasse welche Member enthält, die IDisposable implementieren, selber IDisposable implementieren soll. In der eigenen Dispose-Methode, werden dann die Dispose-Methoden der Members aufgerufen."><meta property="og:type" content="article"><meta property="og:url" content="https://koepalex.github.io/blog/blog/2012-05-13-fxcop-dispose-von-lokalen-variablen/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2012-05-13T00:00:00+00:00"><meta property="article:modified_time" content="2012-05-13T00:00:00+00:00"></head><body><header class=app-header><a href=https://koepalex.github.io/blog/><img class=app-header-avatar src=/blog/avatar.jpg alt="Alexander Köpke"></a>
<span class=app-header-title>Blog von Alexander Köpke</span><p>Technischer Artikel, das Universum und der ganze Rest</p><div class=app-header-social><a href=https://github.com/koepalex target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/koepalex target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>FxCop Dispose von lokalen Variablen</h1><div class=post-meta><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>May 13, 2012</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>2 min read</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://koepalex.github.io/blog/tags/custom-rule/>custom-rule</a>
<a class=tag href=https://koepalex.github.io/blog/tags/dispose/>dispose</a>
<a class=tag href=https://koepalex.github.io/blog/tags/fxcop/>fxcop</a>
<a class=tag href=https://koepalex.github.io/blog/tags/local/>local</a>
<a class=tag href=https://koepalex.github.io/blog/tags/variable/>variable</a></div></div></header><div class=post-content><p>Die Freigabe von Ressourcen (verwaltet und nativ) wird im .Net mittels Implementierung der IDisposable Schnittstelle (bzw. Anwendung des IDisposable Patterns realisiert). Der Aufruf der Dispose-Methode ist so wichtig, dass Microsoft spezielle FxCop Regeln implementiert hat (FxCop ist ein Tool zur statischen Analyse von .Net Assemblys). Die Regel „Disposable fields should be disposed“ (CA2213) besagt, dass eine Klasse welche Member enthält, die IDisposable implementieren, selber IDisposable implementieren soll. In der eigenen Dispose-Methode, werden dann die Dispose-Methoden der Members aufgerufen. Genauso relevant wie Member freizugeben, ist es auch lokale Variablen wieder freizugeben. Für FxCop 1.36 bietet Microsoft keine entsprechende Regel.</p><p>In der Version 10 von FxCop gibt es die Regel „Dispose objects before losing scope“ (CA2000). Diese Regel verursacht einen FxCop Fehler, sollte an einem Objekt nicht die Dispose-Methode aufgerufen werden, bevor alle Referenzen auf dem Objekt „out of scope“ sind. Zusätzlich sollte der Dispose-Aufruf in einem Finally-Block erfolgen, damit Exceptions nicht eine Finalisierung/Freigabe des Objektes unterbinden. Die Anzahl an Fehlermeldungen, welche keine sind, ist bei dieser Regel relativ hoch, zum Beispiel werden Create-Methoden als Fehler erkannt:</p><p>public static DisposableChild RuleNine()
{    
var child = new DisposableChild();    
if (child.Init()) { return child; }    
Debug.Fail(&ldquo;unable to create object&rdquo;);    
return null;
}</p><p>Die von mir für FxCop 1.36 entworfene Regel arbeitet auf wie folgt:</p><p>1. Alle lokalen Variablen überprüfen, ob sie oder eine Basis-Klasse IDisposable implementiert, wobei Compiler-Generierte lokale Variablen ignoriert werden.</p><p>2. Alle Aufrufe von Dispose-Methoden suchen und zu lokalen Variablen zuordnen.</p><p>3. Alle Return-Anweisungen überprüfen, ob sie lokale Variablen, welche IDisposable implementieren zurück liefern.</p><p>4. Ausgabe eines FxCop-Fehlers, von lokalen Variablen, die nicht mittels Return-Anweisung zurückgegeben werden und bei denen auch kein Aufruf der Dispose-Methode erfolgte.</p><p>Den kompletten Quelltext inkl. der benötigte Xml-Datei  (kompiliert als eingebettete Ressource) befindet sich auf pastebin.com:</p><p><a href=http://pastebin.com/QMpZ3pt9>FxCop Rule: Dispose local variables</a></p><p>Viel Erfolg mit der Fehlersuche!</p></div><div class=post-footer></div></article></main></body></html>