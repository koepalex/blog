<!doctype html><html lang=de-de><head><title>WPF RichTextBox mit Durchgestrichenden Text // Blog von Alexander Köpke</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Alexander Köpke"><meta name=description content><link rel=stylesheet href=/blog/css/main.min.3c3c186cd62e563ad6e2f00a89dbee656ab912d1d46f856b5605dd0232521e2a.css><meta name=twitter:card content="summary"><meta name=twitter:title content="WPF RichTextBox mit Durchgestrichenden Text"><meta name=twitter:description content="Um bei einer WPF RichTextBox einen Text Fett, Kursiv oder Unterstrichen darzustellen ist nicht viel notwenig. Eigentlich muss man im XAML nur einen (Toggle)Button definieren, der ein Kommando (EditingCommands) an die RichTextBox sendet:
Genauso einfach verhält es sich einen Text Hochgestellt oder Tiefgestellt darzustellen, mann muss nur zusätzlich noch die Schrift-Familie des Hinter der RichTextBox liegenden Dokumentes verändern:
Die Veränderungen an dem Text funktionieren in zwei Modi:
Ein Text wurde selektiert und der entsprechende Button geklickt, dies bewirkt das nur der selektierte Text beeinflusst wird."><meta property="og:title" content="WPF RichTextBox mit Durchgestrichenden Text"><meta property="og:description" content="Um bei einer WPF RichTextBox einen Text Fett, Kursiv oder Unterstrichen darzustellen ist nicht viel notwenig. Eigentlich muss man im XAML nur einen (Toggle)Button definieren, der ein Kommando (EditingCommands) an die RichTextBox sendet:
Genauso einfach verhält es sich einen Text Hochgestellt oder Tiefgestellt darzustellen, mann muss nur zusätzlich noch die Schrift-Familie des Hinter der RichTextBox liegenden Dokumentes verändern:
Die Veränderungen an dem Text funktionieren in zwei Modi:
Ein Text wurde selektiert und der entsprechende Button geklickt, dies bewirkt das nur der selektierte Text beeinflusst wird."><meta property="og:type" content="article"><meta property="og:url" content="https://koepalex.github.io/blog/blog/2011-06-18-wpf-richtextbox-mit-durchgestrichenden-text/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2011-06-18T00:00:00+00:00"><meta property="article:modified_time" content="2011-06-18T00:00:00+00:00"></head><body><header class=app-header><a href=https://koepalex.github.io/blog/><img class=app-header-avatar src=/blog/avatar.jpg alt="Alexander Köpke"></a>
<span class=app-header-title>Blog von Alexander Köpke</span><p>Technischer Artikel, das Universum und der ganze Rest</p><div class=app-header-social><a href=https://github.com/koepalex target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/koepalex target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>WPF RichTextBox mit Durchgestrichenden Text</h1><div class=post-meta><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Jun 18, 2011</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>2 min read</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://koepalex.github.io/blog/tags/net/>net</a>
<a class=tag href=https://koepalex.github.io/blog/tags/c/>c</a>
<a class=tag href=https://koepalex.github.io/blog/tags/durchgestrichen/>durchgestrichen</a>
<a class=tag href=https://koepalex.github.io/blog/tags/richtextbox/>richtextbox</a>
<a class=tag href=https://koepalex.github.io/blog/tags/strikethrough/>strikethrough</a>
<a class=tag href=https://koepalex.github.io/blog/tags/textdecorator/>textdecorator</a>
<a class=tag href=https://koepalex.github.io/blog/tags/wpf/>wpf</a></div></div></header><div class=post-content><p>Um bei einer WPF RichTextBox einen Text <strong>Fett</strong>, <em>Kursiv</em> oder Unterstrichen darzustellen ist nicht viel notwenig. Eigentlich muss man im XAML nur einen (Toggle)Button definieren, der ein Kommando (EditingCommands) an die RichTextBox sendet:</p><p></p><p>Genauso einfach verhält es sich einen Text Hochgestellt oder Tiefgestellt darzustellen, mann muss nur zusätzlich noch die Schrift-Familie des Hinter der RichTextBox liegenden Dokumentes verändern:</p><p></p><p>Die Veränderungen an dem Text funktionieren in zwei Modi:</p><ol><li>Ein Text wurde selektiert und der entsprechende Button geklickt, dies bewirkt das nur der selektierte Text beeinflusst wird.</li><li>Der Button wird geklickt ohne das Text selektiert ist, dies bewirkt das der danach neu geschriebene Text beeinflusst wird.</li></ol><p>Einen Text Durchgestrichen (Strikethrough) anzuzeigen ist etwas Komplizierter, da die Klasse EditingCommands keine Eigenschaft ToggleStrikethrough besitzt. Im Internet finde man viele Webseiten die einem Zeigen wie man den Modi 1 Implmentiert:</p><p> </p><p>private void myStrikethroughButtonClicked(object sender, RoutedEventArgs e)
{
if(myRichTextBox == null) return;
if(!myRichTextBox.Selection.IsEmpty)
HandleStrikethrouphSelection();
}
private void HandleStrikethrouphSelection()
{
TextDecorationCollection decoratorCollection =
myRichTextBox.Selection.GetPropertyValue(Inline.TextDecorationsProperty) as
TextDecorationCollection;
if(decoratorCollection == null) return;</p><p>TextRange range = new TextRange(myRichTextBox.Selection.Start,
myRichTextBox.Selection.End);</p><p>if(!decoratorCollection.Equals(TextDecorations.Strikethrough))
decoratorCollection = TextDecorations.Strikethrough;
else
decoratorCollection = new TextDecorationCollection();</p><p>range.ApplyPropertyValue(Inline.TextDecorationsProperty, decoratorCollection);
}</p><p>Eine Lösung um den Modi 2 umzusetzen fand ich bei der Internet-Recherce nicht. Daher habe ich so lange Programmiert bis ich eine gefunden habe. Der Trick ist sich im Button-Click-Eventhandler ein Flag zu setzen (bzw. Rücksetzen). Im RichTextBox-TextChanged-Eventhandler wird dieses Flag gelesen um die TextDecorationCollection entweder neu zu erstellen oder auf TextDecorations.Strikethrough zusetzen.</p><p></p><p>private bool IsRtfFlagActive(RtfFlags expected)
{
return (m_ActiveFlags & expected) == expected;
}</p><p>private void ApplyPropertyValueToText(int begin, int end, 
DependencyProperty involvedProperty, object value)</p><p>{
if(begin &lt; 0 || end &lt; 0)
throw new ArgumentException(&ldquo;negative text position isn&rsquo;t supported&rdquo;);
if(involvedProperty == null)
throw new ArgumentNullException(&ldquo;involvedProperty&rdquo;);
if(value == null) throw new ArgumentNullException(&ldquo;value&rdquo;);</p><p>var contentStart = myRichTextBox.Document.ContentStart;
var beginPos = contentStart.GetPositionAtOffset(begin);
var endPos = contentStart.GetPositionAtOffset(end);
var text = new TextRange(beginPos, endPos);
text.ApplyPropertyValue(involvedProperty, value);
}
private void HandleStrikethroughGeneral(int begin, int end)
{
TextDecorationCollection decoratorCollection = myRichTextBox.Selection.GetPropertyValue
(Inline.TextDecorationsProperty) as TextDecorationCollection;
if(decoratorCollection == null) return;</p><p>decoratorCollection = IsRtfFlagActive(RtfFlags.STRIKETHROUGH)
? TextDecorations.Strikethrough
: new TextDecorationCollection();</p><p>ApplyPropertyValueToText(begin, end, Inline.TextDecorationsProperty,
decoratorCollection);
}
private void myStrikethroughButtonClicked(object sender, RoutedEventArgs e)
{
if(myRichTextBox == null) return;</p><p>if(!myRichTextBox.Selection.IsEmpty)
HandleStrikethrouphSelection();
else
UpdateActiveFlags(RtfFlags.STRIKETHROUGH);</p><p>myRichTextBox.Focus();
}</p><p>private void myRichTextBoxTextChanged(object sender, TextChangedEventArgs e)
{
foreach(var change in e.Changes)
{
if(change.RemovedLength == 0)//only work whether something added
HandleStrikethroughGeneral(change.Offset,
change.Offset + change.AddedLength);
}
}</p></div><div class=post-footer></div></article></main></body></html>