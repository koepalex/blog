<!doctype html><html lang=de-de><head><title>Vermeidung von switch-case zur Typen Bestimmung beim Aufruf von generischen Methoden // Blog von Alexander Köpke</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Alexander Köpke"><meta name=description content><link rel=stylesheet href=/blog/css/main.min.3c3c186cd62e563ad6e2f00a89dbee656ab912d1d46f856b5605dd0232521e2a.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Vermeidung von switch-case zur Typen Bestimmung beim Aufruf von generischen Methoden"><meta name=twitter:description content="In der Entwicklung mit .NET hat man öfter folgendes Problem:
Methoden sind generisch implementiert und zu verwendende Objekte sind nur in Form von Referenzen auf Basistypen vorhanden (z.B. System.Array, System.Object). Diese Referenzen können nicht direkt an generische Methode übergeben werden (ergibt einen Compile Fehler).
Häufig liegen daher Typinformationen als String vor (über FullName-Property, aus Konfigurationsdatei, …). Diese Informationen werden anschließend verwendet, um den Typ der Referenz über switch-case aufzulösen.
Zum Beispiel:"><meta property="og:title" content="Vermeidung von switch-case zur Typen Bestimmung beim Aufruf von generischen Methoden"><meta property="og:description" content="In der Entwicklung mit .NET hat man öfter folgendes Problem:
Methoden sind generisch implementiert und zu verwendende Objekte sind nur in Form von Referenzen auf Basistypen vorhanden (z.B. System.Array, System.Object). Diese Referenzen können nicht direkt an generische Methode übergeben werden (ergibt einen Compile Fehler).
Häufig liegen daher Typinformationen als String vor (über FullName-Property, aus Konfigurationsdatei, …). Diese Informationen werden anschließend verwendet, um den Typ der Referenz über switch-case aufzulösen.
Zum Beispiel:"><meta property="og:type" content="article"><meta property="og:url" content="https://koepalex.github.io/blog/blog/2012-04-20-vermeidung-von-switch-case-zur-typen-bestimmung-beim-aufruf-von-generischen-methoden-3/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2012-04-20T00:00:00+00:00"><meta property="article:modified_time" content="2012-04-20T00:00:00+00:00"></head><body><header class=app-header><a href=https://koepalex.github.io/blog/><img class=app-header-avatar src=/blog/avatar.jpg alt="Alexander Köpke"></a>
<span class=app-header-title>Blog von Alexander Köpke</span><p>Technischer Artikel, das Universum und der ganze Rest</p><div class=app-header-social><a href=https://github.com/koepalex target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/koepalex target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Vermeidung von switch-case zur Typen Bestimmung beim Aufruf von generischen Methoden</h1><div class=post-meta><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Apr 20, 2012</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>2 min read</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://koepalex.github.io/blog/tags/case/>case</a>
<a class=tag href=https://koepalex.github.io/blog/tags/cast/>cast</a>
<a class=tag href=https://koepalex.github.io/blog/tags/generic/>generic</a>
<a class=tag href=https://koepalex.github.io/blog/tags/reflection/>reflection</a>
<a class=tag href=https://koepalex.github.io/blog/tags/switch/>switch</a>
<a class=tag href=https://koepalex.github.io/blog/tags/type/>type</a></div></div></header><div class=post-content><p>In der Entwicklung mit .NET hat man öfter folgendes Problem:</p><p>Methoden sind generisch implementiert und zu verwendende Objekte sind nur in Form von Referenzen auf Basistypen vorhanden (z.B. System.Array, System.Object). Diese Referenzen können nicht direkt an generische Methode übergeben werden (ergibt einen Compile Fehler).</p><p>Häufig liegen daher Typinformationen als String vor (über FullName-Property, aus Konfigurationsdatei, …). Diese Informationen werden anschließend verwendet, um den Typ der Referenz über switch-case aufzulösen.</p><p>Zum Beispiel:</p><p>1: public void Foo (Array array)</p><p>2: {</p><p>3: var type = array.GetType();</p><p>4: switch (type.FullName)</p><p>5: {</p><p>6: case „System.Boolean[]“ :</p><p>7: var result = Bar((bool[]) array);</p><p>8: break;</p><p>9: case „System.Int32[]“:</p><p>10: var result = Bar((int[]) array);</p><p>11: break;</p><p>12: case „System.String[]“:</p><p>13: var result = Bar((string[]) array);</p><p>14: break;</p><p>15: case „my.KnownType[]“:</p><p>16: var result = Bar((KnownType[]) array);</p><p>17: break;</p><p>18: case „other.SecondKnownType[]“:</p><p>19: var result = Bar((SecondKnownType[]) array);</p><p>20: break;</p><p>21: case „different.ThirdKnownType[]“:</p><p>22: var result = Bar((ThirdKnownType[]) array);</p><p>23: break;</p><p>24: //&mldr;</p><p>25: }</p><p>26: //do something</p><p>27: }</p><p>28:</p><p>29: public T Bar(T[] elements)</p><p>30: {</p><p>31: //do something</p><p>32: }</p><p>Außer, dass der Quelltext davon aufgebläht wird, funktioniert die Methode nur mit vorher bekannten Typen. Eine Alternative dazu ist die Benutzung von Reflection:</p><p>1: public void Foo (Array array)</p><p>2: {</p><p>3: var type = array.GetType();</p><p>4: var methodInfo = GetType().GetMethod(„Bar“);</p><p>5: var genericMethodInfo = methodInfo.MakeGenericMethod</p><p>6: (type.GetElementType());</p><p>7: var result = genericMethodInfo.Invoke(this,</p><p>8: new object[] {array});</p><p>9: }</p><p>Im Falle von ref, bzw. out Parametern, bei denen eine konkrete Instanz gebraucht wird, kann diese über Activator.CreateInstance(), bzw. Array.CreateInstance() erstellt werden.</p></div><div class=post-footer></div></article></main></body></html>