<!doctype html><html lang=de-de><head><title>Events über Threadgrenzen // Blog von Alexander Köpke</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Alexander Köpke"><meta name=description content><link rel=stylesheet href=/blog/css/main.min.ead1f6492242b7d93618e6840b25260f8ea1ca68dc04cc9cf1b88adcb996693b.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Events über Threadgrenzen"><meta name=twitter:description content="Die meisten Tools/Programme verrichten Ihre Arbeit in Threads um die Oberfläche (UI) nicht zu blockieren. Eine &ldquo;Kommunikations-Möglichkeit&rdquo; um die UI beim Eintreten von bestimmten Gegebenheiten zu benachrichtigen sind Events. Ein Event im .Net ruft seine Ziele (InvokationList) aus dem Thread auf, aus dem es &ldquo;gefeuert&rdquo; wird. UI Controls, können i.A. nur im Mainthread arbeiten. Einen Zugriff aus einen anderen Thread führt zu einer Exception. Über das Interface ISynchronizedInvoke (implementiert von allen ."><meta property="og:title" content="Events über Threadgrenzen"><meta property="og:description" content="Die meisten Tools/Programme verrichten Ihre Arbeit in Threads um die Oberfläche (UI) nicht zu blockieren. Eine &ldquo;Kommunikations-Möglichkeit&rdquo; um die UI beim Eintreten von bestimmten Gegebenheiten zu benachrichtigen sind Events. Ein Event im .Net ruft seine Ziele (InvokationList) aus dem Thread auf, aus dem es &ldquo;gefeuert&rdquo; wird. UI Controls, können i.A. nur im Mainthread arbeiten. Einen Zugriff aus einen anderen Thread führt zu einer Exception. Über das Interface ISynchronizedInvoke (implementiert von allen ."><meta property="og:type" content="article"><meta property="og:url" content="https://koepalex.github.io/blog/blog/2011-06-10-events-uber-threadgrenzen/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2011-06-10T00:00:00+00:00"><meta property="article:modified_time" content="2011-06-10T00:00:00+00:00"></head><body><header class=app-header><a href=https://koepalex.github.io/blog/><img class=app-header-avatar src=/blog/avatar.jpg alt="Alexander Köpke"></a>
<span class=app-header-title>Blog von Alexander Köpke</span><p>Technischer Artikel, das Universum und der ganze Rest</p><div class=app-header-social><a href=https://github.com/koepalex target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/koepalex target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Events über Threadgrenzen</h1><div class=post-meta><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Jun 10, 2011</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>2 min read</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://koepalex.github.io/blog/tags/net/>net</a>
<a class=tag href=https://koepalex.github.io/blog/tags/c/>c</a>
<a class=tag href=https://koepalex.github.io/blog/tags/event/>event</a>
<a class=tag href=https://koepalex.github.io/blog/tags/thread/>thread</a></div></div></header><div class=post-content><p>Die meisten Tools/Programme verrichten Ihre Arbeit in Threads um die Oberfläche (UI) nicht zu blockieren. Eine &ldquo;Kommunikations-Möglichkeit&rdquo; um die UI beim Eintreten von bestimmten Gegebenheiten zu benachrichtigen sind Events. Ein Event im .Net ruft seine Ziele (InvokationList) aus dem Thread auf, aus dem es &ldquo;gefeuert&rdquo; wird. UI Controls, können i.A. nur im Mainthread arbeiten. Einen Zugriff aus einen anderen Thread führt zu einer Exception. Über das Interface ISynchronizedInvoke (implementiert von allen .Net UI Controls):</p><p>public interface ISynchronizeInvoke
{
bool InvokeRequired { get; }
IAsyncResult BeginInvoke (Delegate method, object[] args);
object EndInvoke(IAsyncResult result);
object Invoke(Delegate method, object[] args);
}</p><p>ist es nicht nur möglich nachzufragen ob ein Threadwechsel benötigt wird, er kann damit sogar ausgeführt werden. Damit die Methode zum Senden von Events in anderen Threads wiederverwendbar ist, bietet sich eine statische Hilfemethode an die mit Generics arbeitet und das Senden eines Events mit &ldquo;normaler&rdquo; Signatur unterstützt:</p><p>///  /// Method sending event to right Thread ///  /// &lt;typeparam name=&ldquo;T&rdquo;>Event which should arise /// &lt;typeparam name=&ldquo;K&rdquo;>event arguments /// &lt;typeparam name=&ldquo;G&rdquo;> /// object which is the sender of event /// /// &lt;param name=&ldquo;eventToFire&rdquo;>instance of T /// &lt;param name=&ldquo;args&rdquo;>instance of K /// &lt;param name=&ldquo;instance&rdquo;>instance of G ///  /// this will arise all events with the signature /// void eventname(object sender, K eventargs) ///</p><p>private static void RiseEvent&lt;T, K, G>(T eventToFire, K args, G instance)
where T : clas
{
if(eventToFire != null)
{
MethodInfo methodInfo = typeof (T).GetMethod(&ldquo;GetInvocationList&rdquo;);
if (methodInfo != null)
{
Delegate[] delegates = methodInfo.Invoke(eventToFire, null) as Delegate[];
if (delegates != null)
{
foreach (Delegate del in delegates)
{
ISynchronizeInvoke syncInvoke = del.Target as ISynchronizeInvoke;
if (syncInvoke != null)
{
if (syncInvoke.InvokeRequired)
{
syncInvoke.Invoke(del, new object[] { instance, args });
} else //no invoke requried so &ldquo;normal&rdquo; call delegate
del.DynamicInvoke(new object[] { instance, args });
} else //target don&rsquo;t implement ISynchronizeInvoke > no thread switch
del.DynamicInvoke(new object[] { instance, args });
}//end foreach
} else Debug.Fail(&ldquo;GetInvocationList don&rsquo;t return Delegate[]&rdquo;);
} else Debug.Fail(&ldquo;generic T don&rsquo;t seems to be an event&rdquo;);
} else Debug.Write(&ldquo;wan&rsquo;t to rise event where nobody is registered for&rdquo;);
}</p><p>Verwendet kann die Methode wie folgt werden:</p><p>RiseEvent&lt;DataChanged, DataChangedEventArgs, object>
(this.DataChanged, new DataChangedEventArgs, this);</p></div><div class=post-footer></div></article></main></body></html>