<!doctype html><html lang=de-de><head><title>Immutable Objects am Beispiel von Passwort Hantierung in Java // Blog von Alexander Köpke</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Alexander Köpke"><meta name=description content><link rel=stylesheet href=/blog/css/main.min.ead1f6492242b7d93618e6840b25260f8ea1ca68dc04cc9cf1b88adcb996693b.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Immutable Objects am Beispiel von Passwort Hantierung in Java"><meta name=twitter:description content="In Java sind Strings „Immutable Objects“ (unveränderliche Objekte),
dass bedeutet sie werden zur Laufzeit nicht mehr geändert. Immutables Objects haben viele Vorteile:
im Allgemeinen ist es einfach möglich zu parallelisieren Implementierung von Undo- und Redo-Funktionalitäten sind normalerweise einfach (z.B. mittels Memento-Pattern) James Gosling (einer der Erfinder von Java), gibt zusätzlich an, dass bei Immutable Objects es grundsätzlich möglich ist, Ergebnisse zu Cachen und das die Sicherheit wird erhöht. (vgl. https://www.artima.com/intv/gosling313.html ) Sicherheit ist ein gutes Stichwort, denn Immutable Objects können auch Sicherheitsprobleme mit sich bringen."><meta property="og:title" content="Immutable Objects am Beispiel von Passwort Hantierung in Java"><meta property="og:description" content="In Java sind Strings „Immutable Objects“ (unveränderliche Objekte),
dass bedeutet sie werden zur Laufzeit nicht mehr geändert. Immutables Objects haben viele Vorteile:
im Allgemeinen ist es einfach möglich zu parallelisieren Implementierung von Undo- und Redo-Funktionalitäten sind normalerweise einfach (z.B. mittels Memento-Pattern) James Gosling (einer der Erfinder von Java), gibt zusätzlich an, dass bei Immutable Objects es grundsätzlich möglich ist, Ergebnisse zu Cachen und das die Sicherheit wird erhöht. (vgl. https://www.artima.com/intv/gosling313.html ) Sicherheit ist ein gutes Stichwort, denn Immutable Objects können auch Sicherheitsprobleme mit sich bringen."><meta property="og:type" content="article"><meta property="og:url" content="https://koepalex.github.io/blog/blog/2013-03-02-immutable-objects-am-beispiel-von-passwort-hantierung-in-java/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2013-03-02T00:00:00+00:00"><meta property="article:modified_time" content="2013-03-02T00:00:00+00:00"></head><body><header class=app-header><a href=https://koepalex.github.io/blog/><img class=app-header-avatar src=/blog/avatar.jpg alt="Alexander Köpke"></a>
<span class=app-header-title>Blog von Alexander Köpke</span><p>Technischer Artikel, das Universum und der ganze Rest</p><div class=app-header-social><a href=https://github.com/koepalex target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/koepalex target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Immutable Objects am Beispiel von Passwort Hantierung in Java</h1><div class=post-meta><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Mar 2, 2013</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>4 min read</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://koepalex.github.io/blog/tags/immutable/>immutable</a>
<a class=tag href=https://koepalex.github.io/blog/tags/java-2/>java-2</a>
<a class=tag href=https://koepalex.github.io/blog/tags/passwort/>passwort</a></div></div></header><div class=post-content><p>In Java sind Strings „Immutable Objects“ (unveränderliche Objekte),<br>dass bedeutet sie werden zur Laufzeit nicht mehr geändert.  Immutables Objects haben viele Vorteile:</p><ul><li>im Allgemeinen ist es einfach möglich zu parallelisieren</li><li>Implementierung von Undo- und Redo-Funktionalitäten sind normalerweise einfach (z.B. mittels Memento-Pattern)</li><li>James Gosling (einer der Erfinder von Java), gibt zusätzlich an, dass bei Immutable Objects es grundsätzlich möglich ist, Ergebnisse zu Cachen und das die Sicherheit wird erhöht. (vgl. <a href=https://www.artima.com/intv/gosling313.html>https://www.artima.com/intv/gosling313.html</a> )</li></ul><p>Sicherheit ist ein gutes Stichwort, denn Immutable Objects können auch Sicherheitsprobleme mit sich bringen. Schauen wir uns einmal Passwörter bei Java an. Diese sollten niemals in einem String gespeichert werden, da sie solange der String im Speicher existiert, im Klartext im Speicher stehen. Die allgemeine Empfehlung in verschiedenen Security Guides lautet daher Passwörter nur als Char-Array zu hantieren und sobald man das Passwort nicht mehr benötigt, den Inhalt dieses Array zu überschreiben. Überschreiben funktioniert mit Immutable Objects nicht, was ein Passwort in einem String zu einem Sicherheitsrisiko werden lässt.</p><p>Die Java-Entwickler haben dies natürlich erkannt und u.a. die Methode getText() des JPasswordFields (mit ihren zwei Überladungen) wurden vor geraumer Zeit auf &ldquo;deprecated&rdquo; (obsolet) gesetzt und sollten nicht mehr Verwendet werden. Als Ersatz wurde die Methode getPassword(), welche ein Char-Array zurückliefert, hinzugefügt.So weit, so gut, doch wenn man in die Verlegenheit kommt, in einem JPasswordField ein Passwort zu setzen findet man nur die von JTextComponent geerbte Methode setText(). Diese Methode bekommt als Übergabeparameter einen String, was auch verständlich ist, da JTextComponent die Vaterklasse für alle Text-Controls ist. Die Methode sollte somit nicht verwendet werden. Als Lösung kann man so tun, als ob der Benutzer etwas in das Tastenfeld eingibt und die Zeichen einzeln an das JPasswordField senden:</p><blockquote><p><strong>char</strong>[] password = getPasswordInternal();</p><p><strong>for</strong> (<strong>int</strong> i = 0; i&lt; password.length; i++) {</p><p>  passwordField.dispatchEvent(<strong>new</strong> KeyEvent(passwordField,</p><p>    KeyEvent.<em>KEY_TYPED</em>, System.<em>currentTimeMillis</em>(),</p><p>    0, KeyEvent.<em>VK_UNDEFINED</em>, password[i]));</p><p>}<br>Arrays.<em>fill</em>(password, &lsquo;0&rsquo;);</p></blockquote><p>Ich habe öfter die Frage gehört, warum man ein Passwort automatisch in ein Passwort-Control setzen sollte, es dient ja dazu da um Passworteingaben, von einem Benutzer zu bekommen. So finde ich die Antwort, weil man einen Betriebssystemunabhängigen PasswordManager bauen will oder weil es einfach den Anforderungen entspricht, logisch.</p><p>PasswordManager bieten meist auch die Funktionalität, das Passwort in die Zwischenablage zu kopieren und diese automatisch nach ein paar Sekunden, wieder zu säubern. In Java funktioniert der Zugriff auf die Zwischenablage über die Klasse java.awt.Toolkit.</p><blockquote><p>Toolkit.<em>getDefaultToolkit</em>().getSystemClipboard().setContents(<strong>new</strong> StringSelection(<strong>new</strong> String(password)), <strong>null</strong>);</p></blockquote><p>Doch diese Implementierung ist natürlich nicht akzeptabel, da wieder ein String verwendet wird. Jeder Versuch die StringSelection Klasse mit einer eigenen Transferable Implementierung (siehe <a href=http://docs.oracle.com/javase/1.4.2/docs/api/java/awt/datatransfer/Transferable.html>http://docs.oracle.com/javase/1.4.2/docs/api/java/awt/datatransfer/Transferable.html</a> ), die auf Basis eines Char-Arrays arbeitet, zu ersetzen schlugen bei mir fehl. Als Erläuterung, durch die Vaterklasse Transferable erbt man u.a. die Methode getTransferDataFlavors, bei welcher man ein Array von Unterstützen DataFlavors zurückliefern muss. Jedes Mal, wenn ich einen DataFlavor der sich auf Text oder UnicodeText bezieht, zurück geliefert habe, wurde im Verlauf der setContents Methode, der Rückgabewert der Methode getTransferData auf String gecastet. Was bei einem Char-Array nicht funktioniert. Meine Lösung für dieses Problem ist aufwendig. Und zwar dass via Java Native Access (JNA), für jedes Betriebssystem (Windows, Linux, MacOS, Solaris ) auf die nativen Funktionen zugegriffen wird. Für Windows könnte eine Implementierung wie folgt aussehen:</p><blockquote><p><strong>interface</strong> Kernel32Lib <strong>extends</strong> StdCallLibrary</p><p>{</p><p>  Pointer GlobalLock(Pointer hResult);</p><p>  Pointer GlobalUnlock(Pointer hResult);</p><p>  Pointer GlobalAlloc(<strong>int</strong> uFlags, <strong>int</strong> dwBytes);</p><p>  Pointer GlobalFree(Pointer hResult);</p><p>}</p><p><strong>interface</strong> User32Lib <strong>extends</strong> StdCallLibrary</p><p>{</p><p>  <strong>boolean</strong> OpenClipboard(Pointer hInstance);</p><p>  <strong>boolean</strong> EmptyClipboard();</p><p>  Pointer SetClipboardData(<strong>int</strong> uFormat, Pointer hMem);</p><p>  <strong>boolean</strong> CloseClipboard();</p><p>}</p><p><strong>class</strong> Kernel32Wrapper {</p><p>  <strong>private</strong> Kernel32Lib _Instance;</p><p>  <strong>private</strong> Pointer _Memory;</p><p>  <strong>private</strong> Pointer _LockedMemory;</p><p>  <strong>private</strong> <strong>final</strong> <strong>static</strong> <strong>int</strong> <em>GMEM_MOVEABLE</em> = 0x2;</p><p>  <strong>private</strong> <strong>final</strong> <strong>static</strong> <strong>int</strong> <em>GMEM_ZEROINIT</em> = 0x40;</p><p>Kernel32Wrapper() {</p><p>  _Instance = (Kernel32Lib) Native.<em>loadLibrary</em><br>     (&ldquo;Kernel32&rdquo;, Kernel32Lib.<strong>class</strong>);</p><p>}</p><p><strong>public</strong> Pointer allocate(<strong>int</strong> size) {</p><p>  _Memory = _Instance.GlobalAlloc(<em>GMEM_MOVEABLE</em> |<br>    <em>GMEM_ZEROINIT</em>, size);</p><p>  <strong>if</strong> (_Memory == <strong>null</strong>) {</p><p>    <strong>int</strong> errno = Native.<em>getLastError</em>();</p><p>    System.<em>out</em>.println(errno);</p><p>  }</p><p>  <strong>return</strong> _Memory;</p><p>}</p><p><strong>public</strong> <strong>boolean</strong> free() {</p><p>  <strong>boolean</strong> result = <strong>false</strong>;</p><p>  <strong>if</strong> (_Memory != <strong>null</strong>) {</p><p>    result = _Instance.GlobalFree(_Memory) != <strong>null</strong>;</p><p>    _Memory = <strong>null</strong>;</p><p>  }</p><p>  <strong>return</strong> result;</p><p>}</p><p><strong>public</strong> Pointer lock() {</p><p>  _LockedMemory = _Instance.GlobalLock(_Memory);</p><p>  <strong>if</strong> (_LockedMemory == <strong>null</strong>) {</p><p>    <strong>int</strong> errno = Native.<em>getLastError</em>();</p><p>    System.<em>out</em>.println(errno);</p><p>  }</p><p>  <strong>return</strong> _LockedMemory;</p><p>}</p><p><strong>public</strong> <strong>void</strong> unlock() {</p><p>  <strong>if</strong> (_LockedMemory != <strong>null</strong>) {</p><p>  _Instance.GlobalUnlock(_LockedMemory);</p><p>  _LockedMemory = <strong>null</strong>;</p><p>}</p><p>}</p><p>}</p><p><strong>class</strong> Win32ClipboardService {</p><p><strong>private</strong> <strong>final</strong> <strong>static</strong> <strong>int</strong> <em>CF_UNICODETEXT</em> = 13;</p><p><strong>private</strong> User32Lib _Instance;</p><p><strong>private</strong> Kernel32Wrapper _Kernel32;</p><p>Win32ClipboardService () {</p><p>  _Instance = (User32Lib) Native.<em>loadLibrary</em>(&ldquo;User32&rdquo;,  User32Lib.<strong>class</strong>);</p><p>  _Instance.OpenClipboard(<strong>null</strong>);</p><p>  _Kernel32 = <strong>new</strong> Kernel32Wrapper();</p><p>}</p><p><strong>public</strong> <strong>void</strong> setClipboard(<strong>char</strong>[] password) {</p><p>  <strong>byte</strong>[] buff = <em>convertCharArrayToByteArray</em>(password);</p><p>  <strong>int</strong> size = buff.length + 2;</p><p>  Pointer hResult = _Kernel32.allocate(size);</p><p>  <strong>if</strong> (hResult != <strong>null</strong>)</p><p>  {</p><p>    Pointer globalMem = _Kernel32.lock();</p><p>    <strong>if</strong> (globalMem != <strong>null</strong>)</p><p>    {</p><p>      ByteBuffer bBuff = globalMem.getByteBuffer(0, buff.length);</p><p>        bBuff.put(buff);</p><p>      _Kernel32.unlock();</p><p>      globalMem = <strong>null</strong>;</p><p>      _Instance.SetClipboardData(<em>CF_UNICODETEXT</em>, hResult);</p><p>    }</p><p>  }</p><p>  Arrays.<em>fill</em>(buff, 0, buff.length, (<strong>byte</strong>)0);</p><p>}</p><p><strong>public</strong> <strong>void</strong> clearClipboard() {</p><p>  _Instance.EmptyClipboard();</p><p>}</p><p><strong>public</strong> <strong>void</strong> close() {</p><p>  _Instance.CloseClipboard();</p><p>  _Kernel32.free();</p><p>}</p><p>private <strong>static</strong> <strong>byte</strong>[] convertCharArrayToByteArray(<strong>char</strong>[] password) {</p><p>  <strong>byte</strong>[] result = <strong>new</strong> <strong>byte</strong> [password.length * 2];</p><p>  <strong>for</strong> (<strong>int</strong> i = 0; i &lt; password.length; i++) {</p><p>    result[i * 2] = (<strong>byte</strong>) password[i];</p><p>    result[i * 2 + 1]=(<strong>byte</strong>) (password[i] &#187; 8);</p><p>  }</p><p>  <strong>return</strong> result;</p><p>}</p><p>}</p></blockquote></div><div class=post-footer></div></article></main></body></html>