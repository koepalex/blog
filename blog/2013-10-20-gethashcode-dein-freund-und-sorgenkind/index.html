<!doctype html><html lang=de-de><head><title>GetHashCode dein Freund und Sorgenkind // Blog von Alexander Köpke</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Alexander Köpke"><meta name=description content><link rel=stylesheet href=/blog/css/main.min.ead1f6492242b7d93618e6840b25260f8ea1ca68dc04cc9cf1b88adcb996693b.css><meta name=twitter:card content="summary"><meta name=twitter:title content="GetHashCode dein Freund und Sorgenkind"><meta name=twitter:description content="Eine wichtige Methode beim Arbeiten im .NET Umfeld ist GetHashCode. Sie gibt einen 32 Bit Integer zurück der das Objekt identifizieren soll. Der Hash-Code beschreibt also die Identität des Objektes (im Gegensatz zur Speicherreferenz auf das Objekt).
Daraus leitet sich die Frage ab Wann zwei Objekte die selbe Identität besitzen? Im Falle einer Object-Relational-Mapper Klasse beispielsweise, wenn die Instanzen der O/R-Mapper Klasse auf ein und die selbe Zeile(n) der selben Tabelle(n) der selben Datenbank(en) verweisen."><meta property="og:title" content="GetHashCode dein Freund und Sorgenkind"><meta property="og:description" content="Eine wichtige Methode beim Arbeiten im .NET Umfeld ist GetHashCode. Sie gibt einen 32 Bit Integer zurück der das Objekt identifizieren soll. Der Hash-Code beschreibt also die Identität des Objektes (im Gegensatz zur Speicherreferenz auf das Objekt).
Daraus leitet sich die Frage ab Wann zwei Objekte die selbe Identität besitzen? Im Falle einer Object-Relational-Mapper Klasse beispielsweise, wenn die Instanzen der O/R-Mapper Klasse auf ein und die selbe Zeile(n) der selben Tabelle(n) der selben Datenbank(en) verweisen."><meta property="og:type" content="article"><meta property="og:url" content="https://koepalex.github.io/blog/blog/2013-10-20-gethashcode-dein-freund-und-sorgenkind/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2013-10-20T00:00:00+00:00"><meta property="article:modified_time" content="2013-10-20T00:00:00+00:00"></head><body><header class=app-header><a href=https://koepalex.github.io/blog/><img class=app-header-avatar src=/blog/avatar.jpg alt="Alexander Köpke"></a>
<span class=app-header-title>Blog von Alexander Köpke</span><p>Technischer Artikel, das Universum und der ganze Rest</p><div class=app-header-social><a href=https://github.com/koepalex target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/koepalex target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>GetHashCode dein Freund und Sorgenkind</h1><div class=post-meta><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Oct 20, 2013</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>4 min read</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://koepalex.github.io/blog/tags/gethashcode/>gethashcode</a>
<a class=tag href=https://koepalex.github.io/blog/tags/hash/>hash</a>
<a class=tag href=https://koepalex.github.io/blog/tags/performance/>performance</a></div></div></header><div class=post-content><p>Eine wichtige Methode beim Arbeiten im .NET Umfeld ist GetHashCode. Sie gibt einen 32 Bit Integer zurück der das Objekt identifizieren soll. Der Hash-Code beschreibt also die Identität des Objektes (im Gegensatz zur Speicherreferenz auf das Objekt).</p><p>Daraus leitet sich die Frage ab <em>Wann zwei Objekte die selbe Identität besitzen?</em> Im Falle einer Object-Relational-Mapper Klasse beispielsweise, wenn die Instanzen der O/R-Mapper Klasse auf ein und die selbe Zeile(n) der selben Tabelle(n) der selben Datenbank(en) verweisen. Klassischer weise durch eine Kette von Primary-Keys. Der Hash-Code ist auch ein Sorgenkind eines Entwicklers da schon hier die Probleme beginnen. Eine einfach Implementierungen könnte sein: <code>return (tableKey.GetHashCode()+ key1.GetHashCode() + keyN.GetHashCode());</code> Diese ist jedoch Falsch denn die Addition von unterschiedlichen Summanden kann die gleichen Summe ergeben. Eine verbesserte Implementierung ist: <code>return string.Concat(tableKey, key1, keyN).GetHashCode();</code> Jedoch beinhaltet auch diese Implementierung einen unscheinbaren Fehler.</p><ul><li>key1: &ldquo;ab&rdquo; keyN: &ldquo;c&rdquo; ergibt <em>&ldquo;abc&rdquo;</em>.GetHashCode()</li><li>key1: &ldquo;a&rdquo; keyN &ldquo;bc&rdquo; ergibt auch <em>&ldquo;abc&rdquo;</em>.GetHashCode()</li></ul><p>Eine weiter verbesserte Implementierung ist: <code>return string.Format("{0} : {1} : {2}", tableKey, key1, keyN) .GetHashCode();</code> Um jedoch einen noch besseren Hash-Code zu berechnen müsste man die Hash-Code der einzelnen Felder generieren und diese mittels einer Hash-Funktion verarbeiten. Beispiele für Hash-Funktionen sind:</p><ol><li><a href=http://en.wikipedia.org/wiki/Jenkins_hash_function>Jenkins</a></li><li><a href=http://en.wikipedia.org/wiki/Murmurhash>Murmur</a></li><li><a href=http://en.wikipedia.org/wiki/CityHash>CityHash</a></li><li><a href="http://www.webcitation.org/query?url=http://www.geocities.com/drone115b/Goulburn06.pdf&amp;date=2009-10-25+21:06:51">Goulburn</a></li></ol><p>Empfehlenswert ist diese letzte Variante nur für Programme die mit großen Datenmengen arbeiten müssen oder mit besonders langen Laufzeiten haben (z.B. Server-Anwendungen).</p><hr><p>Die Symbole <em>tableKey</em>, <em>key1</em> und <em>keyN</em> im oberen Beispiel sollten am besten als <strong>readonly</strong> gekennzeichnet werden und zwar aufgrund der <a href=http://msdn.microsoft.com/en-us/library/system.object.gethashcode.aspx>Microsoft GetHashCode Guidelines</a></p><blockquote><p><strong>&ldquo;the integer returned by GetHashCode should never change&rdquo;</strong></p></blockquote><p>Ein veränderlicher Hash-Code ist unter anderem Problematisch wenn:</p><ol><li>Ein Objekt in einer Datenstruktur (wie Hashset) enthalten ist.</li><li>Das Objekt so modifiziert wird, dass sich sein Hash-Code verändert.<ul><li>Nun ist es eher vom Zufall abhängig ob sich das Objekt noch im richtigen <a href=http://msdn.microsoft.com/en-us/library/ms379571.aspx><strong>bucket</strong></a> der Datenstruktur befindet. Wenn nicht ist das Objekt in der Datenstruktur verwaist.</li><li>Existieren andere Instanzen die auf die gleiche Identität zeigen sollten beinhaltet man die Software ab diesem Zeitpunkt einen schwer zu lokalisierenden Fehler.</li></ul></li></ol><p>In der Realität ist es nicht immer möglich den erzeugten Hash-Code stabil zu halten, meist weil man Ressourcen sparend programmieren muss (z.B. Objekte wieder verwenden da <em>teure</em> Ressourcen benutzen). Deswegen hat sich der Microsoft Mitarbeiter <em>Eric Lippert</em> solcher Probleme angenommen und in seinem Blog den sehr lesenswerten Eintrag <a href=http://blogs.msdn.com/b/ericlippert/archive/2011/02/28/guidelines-and-rules-for-gethashcode.aspx>Guidelines and rules for GetHashCode</a> verfasst. Darin heißt es unter anderem:</p><blockquote><p><strong>&ldquo;Rule: the integer returned by GetHashCode should never change while the object is contained in a data structure that depends on the hash code remaining stable&rdquo;</strong></p></blockquote><hr><p>Eine andere Problematik ergibt sich aus der Tatsache, dass der Hash-Code <em>nur</em> 32 Bit groß ist. Der rund 4,2 Milliarden Zahlen fassende Zahlenraum kann nur effektiv ausgenutzt werden, wenn die verwendete Hash-Funktion die Hash-Codes möglichst gleichmäßig über den Zahlenraum verteilt.</p><p>Selbst mit einer Optimalen Hash-Funktion gilt jedoch, dass je mehr Hash-Codes ermittelt werden desto höher ist die Wahrscheinlichkeit einer Hash-Kollision. Eine Kollision entsteht wenn zwei unterschiedliche Identitäten existieren, für welche derselbe Hash-Code generiert wird. <em>Eric Lippert</em> hat ermittelt, dass bei nur 9300 generierten Hashes die Chance einer Kollision 1 % beträgt. Für 77000 Objekte beträgt die Chance bereits 50% <a href=http://blogs.msdn.com/b/ericlippert/archive/2010/03/22/socks-birthdays-and-hash-collisions.aspx>vgl. Socks, birthdays and hash collisions</a>. Daher ist es eine schlechte Idee, alle Objekte in einer Datenstruktur zu verwalten und somit den Hash-Code als globalen Identifizier zu verwenden.</p><hr><p>Die dritte Problematik welche ich ansprechen möchte ist Performance. Falsch Implementierte oder schlecht ausgewählte Hash-Funktionen können die Laufzeit eines Programms deutlich verschlechtern. Die Performance-Verschlechterungen treten u.a. auf wenn eine Hash-Funktion:</p><ul><li>zu lange braucht um den Hash-Code zu berechnen (Kryptographische Hash-Funktionen eigenen sich i.d.R. nicht für GetHashCode)</li><li>nicht den gesamten Zahlenraum nutzen, dann dauert das einfügen von Elementen in eine Datenstruktur sehr lange (häufige Kollisionen)</li></ul><p>Der letzte Punkt ist eine bekannte Falle bei der Verwendung von <em>structs</em>. Bei einem Struct sollte die GetHashCode-Methode immer überschrieben werden, da die Standardimplementierung nur einen kleinen Teil des Zahlenraums ausnutzt siehe <a href="http://tutorials.csharp-online.net/index.php?title=CSharp_FAQ:_Why_are_hashtable_lookups_so_slow_with_struct_keys">C# FAQ: Why are hashtable lookups so slow with struct keys</a>.</p></div><div class=post-footer></div></article></main></body></html>