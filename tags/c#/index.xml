<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c# on</title><link>https://www.alexander-koepke.de/tags/c#/</link><description>Recent content in c# on</description><generator>Hugo -- gohugo.io</generator><language>de-de</language><lastBuildDate>Sat, 18 Jun 2011 00:00:00 +0000</lastBuildDate><atom:link href="https://www.alexander-koepke.de/tags/c#/index.xml" rel="self" type="application/rss+xml"/><item><title>WPF RichTextBox mit Durchgestrichenden Text</title><link>https://www.alexander-koepke.de/post/2011-06-18-wpf-richtextbox-mit-durchgestrichenden-text/</link><pubDate>Sat, 18 Jun 2011 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2011-06-18-wpf-richtextbox-mit-durchgestrichenden-text/</guid><description>Um bei einer WPF RichTextBox einen Text Fett, Kursiv oder Unterstrichen darzustellen ist nicht viel notwenig. Eigentlich muss man im XAML nur einen (Toggle)Button definieren, der ein Kommando (EditingCommands) an die RichTextBox sendet:
&amp;lt;ToggleButton Command=&amp;#34;EditingCommands.ToggleItalic&amp;#34; CommandTarget=&amp;#34;{Binding ElementName=myRichTextBox}&amp;#34; Content=&amp;#34;Italic&amp;#34;/&amp;gt; &amp;lt;RichTextBox/&amp;gt; Genauso einfach verhält es sich einen Text Hochgestellt oder Tiefgestellt darzustellen, mann muss nur zusätzlich noch die Schrift-Familie des Hinter der RichTextBox liegenden Dokumentes verändern:
&amp;lt;ToggleButton Command=&amp;#34;EditingCommands.ToggleSubscript&amp;#34; CommandTarget=&amp;#34;{Binding ElementName=myRichTextBox}&amp;#34; Content=&amp;#34;Subscript&amp;#34;/&amp;gt; &amp;lt;RichTextBox/&amp;gt; &amp;lt;!</description></item><item><title>Events über Threadgrenzen</title><link>https://www.alexander-koepke.de/post/2011-06-10-events-uber-threadgrenzen/</link><pubDate>Fri, 10 Jun 2011 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2011-06-10-events-uber-threadgrenzen/</guid><description>Die meisten Tools/Programme verrichten Ihre Arbeit in Threads um die Oberfläche (UI) nicht zu blockieren. Eine &amp;ldquo;Kommunikations-Möglichkeit&amp;rdquo; um die UI beim Eintreten von bestimmten Gegebenheiten zu benachrichtigen sind Events. Ein Event im .Net ruft seine Ziele (InvokationList) aus dem Thread auf, aus dem es &amp;ldquo;gefeuert&amp;rdquo; wird. UI Controls, können i.A. nur im Mainthread arbeiten. Einen Zugriff aus einen anderen Thread führt zu einer Exception. Über das Interface ISynchronizedInvoke (implementiert von allen .</description></item><item><title>Tracing/Logging und die Config-Datei</title><link>https://www.alexander-koepke.de/post/2011-06-08-tracinglogging-config-file/</link><pubDate>Wed, 08 Jun 2011 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2011-06-08-tracinglogging-config-file/</guid><description>Logging von Informationen ist so gut wie in jedem Programm notwendig. Nicht alle Entwickler können oder wollen ein professionelles Log-Tool wie z.B. log4net oder nlog verwenden. In vielen Fällen reichen auch Debug.WriteLine oder Trace.WriteLine (letztes schreibt auch wenn die Software im Modus „Release“ kompiliert wurde).
Über eine Config-Datei lassen sich u.a. verschiedene TraceListener auswählen:
ConsoleTraceListener DefaultTraceListener DelimitedListTraceListener EventLogTraceListener EventSchemaTraceListener TextWriterTraceListener XmlWriterTraceListener eigene Implementierungen welche sich von TraceListener ableiten Damit kann man ohne neu kompilieren des Assemblies einfach den Ausgabeort des Trace-Informationen verändern.</description></item><item><title>Einiges über IDisposable</title><link>https://www.alexander-koepke.de/post/2011-06-07-something-idisposable/</link><pubDate>Tue, 07 Jun 2011 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2011-06-07-something-idisposable/</guid><description>Das Standard Interface IDisposable welches zur &amp;ldquo;Freigabe&amp;rdquo; von Ressourcen in .Net dient ist recht Einfach:
public interface IDisposable { void Dispose(); } Nur dieses Interface zu Implementieren reicht in vielen Fällen nicht aus. Es gibt z.B. einen FxCop Fehler Implement IDisposable correctly, dieser erscheint u.a. bei non-sealed Klassen welche keinen Medthode mit der Signatur protected virtual Dispose(bool) besitzen. IDisposable zu Implementieren wird nötig wenn man:
unmanged (native) Ressourcen lädt um diese wieder freizugeben managed Felder besitzt, welche wiederum IDisposable implementieren Im folgenden Beispiel zeigt eine (nach FxCop komplette Implementierung) einer Basis-Klasse und einer Kind-Klasse:</description></item></channel></rss>