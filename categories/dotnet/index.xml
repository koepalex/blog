<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>dotnet on</title><link>https://www.alexander-koepke.de/categories/dotnet/</link><description>Recent content in dotnet on</description><generator>Hugo -- gohugo.io</generator><language>de-de</language><lastBuildDate>Thu, 14 Jul 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://www.alexander-koepke.de/categories/dotnet/index.xml" rel="self" type="application/rss+xml"/><item><title>Zeit-Trennzeichen bei DateTime</title><link>https://www.alexander-koepke.de/post/2016-07-14-zeit-trennzeichen-bei-datetime/</link><pubDate>Thu, 14 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2016-07-14-zeit-trennzeichen-bei-datetime/</guid><description>Diese Woche hat es das .NET geschafft mich zu überraschen, ein Programm ist beim Kunden mit italienischen Windows immer wieder abgestürzt. Nach langem Suchen hat ein Kollege das Problem erkannt, was durch das folgende Beispiel veranschaulicht wird:
var ci = new CultureInfo(&amp;#34;it-IT&amp;#34;); var dateTime = DateTime.Now; var str = dateTime.ToString(&amp;#34;dd.mm.yyyy hh:mm:ss&amp;#34;, ci); Console.WriteLine(str); Ausgabe (.NET 3.5): 14.07.2016 20.45.30
Ausgabe (.NET 4.0): 14.07.2016 20:45:30
In der Ausgabe erkennt man, dass abhängig von der .</description></item><item><title>Performance Vortrag aus 2015</title><link>https://www.alexander-koepke.de/post/2016-06-13-performance-vortrag-aus-2015/</link><pubDate>Mon, 13 Jun 2016 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2016-06-13-performance-vortrag-aus-2015/</guid><description>Letztes Jahr habe ich einen Vortrag zum Thema Performance gehalten, der Vermitteln sollte warum dieses Thema jeden (.NET-)Entwickler betrifft.
Nachdem ich mir jetzt die Zeit genommen habe um auch die Sprechernotizen aka &amp;ldquo;Tonspur&amp;rdquo; auf zuschreiben, konnte ich den Vortrag online stellen:
https://github.com/koepalex/performance_talk_2015
Vielleicht ist der Vortrag für jemanden Hilfreich :)</description></item><item><title>Debugging von Performance Problemen in .NET</title><link>https://www.alexander-koepke.de/post/2013-11-27-debugging-von-performance-problemen-in-net/</link><pubDate>Wed, 27 Nov 2013 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2013-11-27-debugging-von-performance-problemen-in-net/</guid><description>Die Analyse von Speicherproblemen ist eine Aufgabe die bei großen .NET Anwendungen häufiger vorkommt. In C++ wurde gesucht, wer welche Speicherblöcke angefordert und nicht wieder freigegeben hat und im .NET Umfeld wird eben gesucht warum der Gabarge-Collector den Speicher nicht freigeben kann. Oder man sucht warum einige Benutzeraktionen besonders lange benötigen. Für die Analyse gibt es eine ganze Reihe guter kommerzieller Programme, auf diese möchte ich jedoch nicht eingehen, sondern ein paar kostenlosen Alternativen vorstellen.</description></item><item><title>Neues vom GC in .NET 4.0 und 4.5</title><link>https://www.alexander-koepke.de/post/2013-10-21-neues-vom-gc-in-net-4-0-und-4-5/</link><pubDate>Mon, 21 Oct 2013 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2013-10-21-neues-vom-gc-in-net-4-0-und-4-5/</guid><description>Heute möchte ich etwas über Erneuerungen im .NET 4.0 / 4.5 sprechen. Das genannte bezieht sich auf den Workstation Garbage-Collector. Die Informationen für den Server Garbage-Collector entnehmen sie bitte den Links. Beginnen wir jedoch zunächst mit einer kurzen Auffrischung.
Wiederholung Das .NET Framework unterteilt seinen Heap in verschiedene Generationen.
In der Gen0 werden fast alle Objekte erstellt. Die Anfangsgröße beträgt rund 256KB. In der Gen1 werden Objekte gespeichert die eine Garbage-Collection überlebt haben.</description></item><item><title>GetHashCode dein Freund und Sorgenkind</title><link>https://www.alexander-koepke.de/post/2013-10-20-gethashcode-dein-freund-und-sorgenkind/</link><pubDate>Sun, 20 Oct 2013 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2013-10-20-gethashcode-dein-freund-und-sorgenkind/</guid><description>Eine wichtige Methode beim Arbeiten im .NET Umfeld ist GetHashCode. Sie gibt einen 32 Bit Integer zurück der das Objekt identifizieren soll. Der Hash-Code beschreibt also die Identität des Objektes (im Gegensatz zur Speicherreferenz auf das Objekt).
Daraus leitet sich die Frage ab Wann zwei Objekte die selbe Identität besitzen? Im Falle einer Object-Relational-Mapper Klasse beispielsweise, wenn die Instanzen der O/R-Mapper Klasse auf ein und die selbe Zeile(n) der selben Tabelle(n) der selben Datenbank(en) verweisen.</description></item><item><title>Pipe aus eigenen Programmen nutzen</title><link>https://www.alexander-koepke.de/post/2013-10-13-pipe-aus-eigenen-programmen-nutzen/</link><pubDate>Sun, 13 Oct 2013 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2013-10-13-pipe-aus-eigenen-programmen-nutzen/</guid><description>Mittels der von Unix Systemen bekannten Pipe (|) ist es auch unter Windows (via CMD-Line) möglich einzelne Kommandos zu verbinden. Die Pipe ermöglicht es die Ausgabe vom dem vorherigen Kommando direkt als Input des aktuellen Kommandos zu verwenden. Beispielsweise den Inhalt einer Datei einem Skript zu übergeben: type input.md | perl Markdown.pl &amp;gt; output.html
Logisch gesehen Ersetzt der Inhalt der Pipe ein einzelnes Konsolen-Argument. Um diese Funktionalität auch in den eigenen (Konsolen-) Programme verwenden zu können, sind im Allgemeinen nur zwei Erweiterungen notwendig.</description></item><item><title>Ermitteln des PID (Processidentifier) des Vaterprozesses</title><link>https://www.alexander-koepke.de/post/2012-10-14-ermitteln-des-pid-processidentifier-des-vaterprozesses/</link><pubDate>Sun, 14 Oct 2012 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2012-10-14-ermitteln-des-pid-processidentifier-des-vaterprozesses/</guid><description>In manchen Fällen ist es notwendig heraus zu finden, welches der Vaterprozess eines Prozesses ist. Dafür gibt es im Allgemeinen drei verschiedene Lösungen im Windows .NET Umfeld.
Die häufigste Lösung ist die Verwendung von Performancecountern.
var process = FindProcess(); using (var pC = new PerformanceCounter( &amp;#34;Process&amp;#34;, &amp;#34;Creating Process ID&amp;#34;, string.Format(&amp;#34;{0}#{1}&amp;#34;, process.ProcessName, 1), process.MachineName)) { int pid = (int)pC.NextValue(); Console.WriteLine(&amp;#34;parent pid = {0}&amp;#34;, pid); } Die Verwendung von Performancecountern im Allgemeinen kann zwei mögliche Nachteile haben:</description></item><item><title>DSLs, Extension Methods und Fluent Interfaces</title><link>https://www.alexander-koepke.de/post/2012-07-28-dsls-extension-methods-und-fluent-interfaces/</link><pubDate>Sat, 28 Jul 2012 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2012-07-28-dsls-extension-methods-und-fluent-interfaces/</guid><description>In den letzten Jahren wurde in der Softwareentwicklung viel über Domänenspezifische Sprachen (domain specific language, kurz: DSLs) geschrieben. DSLs sollen von einem Domänenexperten gelesen werden können, auch ohne das die Domänenexperten über Programmierkenntnisse verfügen. DSLs können auch Entwicklern helfen die Quelltexte leserlicher zu machen, sowie Fehler zu vermeiden. Die Quelltextzeile:
if (!SessionEstablished)
Ist einfach verständlich (für diejenigen welche eine C ähnliche Syntax verstehen), als Alternative könnte folgende Quelltextzeile dienen:
if (Not(SessionEstablished))</description></item><item><title>Inversion Of Control(-Container), Service Locator und Dependency Injection</title><link>https://www.alexander-koepke.de/post/2012-06-08-inversion-of-control-container-service-locator-und-dependency-injection/</link><pubDate>Fri, 08 Jun 2012 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2012-06-08-inversion-of-control-container-service-locator-und-dependency-injection/</guid><description>IOC-Container und DI sind zurzeit in vielen Fachzeitschriften diskutiert. Hier der Versuch einer kompakte Übersicht, die IOC, DI, SL und IOC-Container im Zusammenspiel erklärt.
Inversion Of Control
Beschreibt ein Paradigma zum Entwerfen von Frameworks. Ein Unterschied zwischen einem Framework und einer Bibliothek besteht darin, dass in einem Framework Methoden vom Verwender des Framework aufgerufen werden. Dies verändert den Kontrollfluss, bei einer klassischen Bibliothek, ruft der Verwender eine Methode auf, deren Funktionalität wird abgearbeitet und die Methode kehrt zum Aufrufer zurück.</description></item><item><title>Vermeidung von switch-case zur Typen Bestimmung beim Aufruf von generischen Methoden</title><link>https://www.alexander-koepke.de/post/2012-04-20-vermeidung-von-switch-case-zur-typen-bestimmung-beim-aufruf-von-generischen-methoden-3/</link><pubDate>Fri, 20 Apr 2012 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2012-04-20-vermeidung-von-switch-case-zur-typen-bestimmung-beim-aufruf-von-generischen-methoden-3/</guid><description>In der Entwicklung mit .NET hat man öfter folgendes Problem:
Methoden sind generisch implementiert und zu verwendende Objekte sind nur in Form von Referenzen auf Basistypen vorhanden (z.B. System.Array, System.Object). Diese Referenzen können nicht direkt an generische Methode übergeben werden (ergibt einen Compile Fehler).
Häufig liegen daher Typinformationen als String vor (über FullName-Property, aus Konfigurationsdatei, …). Diese Informationen werden anschließend verwendet, um den Typ der Referenz über switch-case aufzulösen.
Zum Beispiel:</description></item><item><title>UnauthorizedAccessException beim Kopieren einer Datei</title><link>https://www.alexander-koepke.de/post/2011-11-07-unauthorizedaccessexception-beim-kopieren-einer-datei/</link><pubDate>Mon, 07 Nov 2011 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2011-11-07-unauthorizedaccessexception-beim-kopieren-einer-datei/</guid><description>Kopieren, verschieben, umbenennen und löschen von Dateien gehören zu häufigen Aufgaben eines Softwareentwicklers. In diesem Beitrag sollen ein paar Dinge aufgezeigt werden die einem beim kopieren von Datein vielleicht nicht bewusst sind. Wie kopiert man jetzt am besten eine Datei? Eine Variante ist die statische Methode der Klasse File:
File.Copy(“C:\\input\\test.bmp“, “C:\\output\\test.bmp“, true); Damit man sich Überprüfungen wie ob die Datei bereits existiert (File.Exist()) sparen kann, wird die Überladung der Copy-Methode verwendet, welche bestehende Dateien überschreibt.</description></item><item><title>WPF RichTextBox mit Durchgestrichenden Text</title><link>https://www.alexander-koepke.de/post/2011-06-18-wpf-richtextbox-mit-durchgestrichenden-text/</link><pubDate>Sat, 18 Jun 2011 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2011-06-18-wpf-richtextbox-mit-durchgestrichenden-text/</guid><description>Um bei einer WPF RichTextBox einen Text Fett, Kursiv oder Unterstrichen darzustellen ist nicht viel notwenig. Eigentlich muss man im XAML nur einen (Toggle)Button definieren, der ein Kommando (EditingCommands) an die RichTextBox sendet:
&amp;lt;ToggleButton Command=&amp;#34;EditingCommands.ToggleItalic&amp;#34; CommandTarget=&amp;#34;{Binding ElementName=myRichTextBox}&amp;#34; Content=&amp;#34;Italic&amp;#34;/&amp;gt; &amp;lt;RichTextBox/&amp;gt; Genauso einfach verhält es sich einen Text Hochgestellt oder Tiefgestellt darzustellen, mann muss nur zusätzlich noch die Schrift-Familie des Hinter der RichTextBox liegenden Dokumentes verändern:
&amp;lt;ToggleButton Command=&amp;#34;EditingCommands.ToggleSubscript&amp;#34; CommandTarget=&amp;#34;{Binding ElementName=myRichTextBox}&amp;#34; Content=&amp;#34;Subscript&amp;#34;/&amp;gt; &amp;lt;RichTextBox/&amp;gt; &amp;lt;!</description></item><item><title>Events über Threadgrenzen</title><link>https://www.alexander-koepke.de/post/2011-06-10-events-uber-threadgrenzen/</link><pubDate>Fri, 10 Jun 2011 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2011-06-10-events-uber-threadgrenzen/</guid><description>Die meisten Tools/Programme verrichten Ihre Arbeit in Threads um die Oberfläche (UI) nicht zu blockieren. Eine &amp;ldquo;Kommunikations-Möglichkeit&amp;rdquo; um die UI beim Eintreten von bestimmten Gegebenheiten zu benachrichtigen sind Events. Ein Event im .Net ruft seine Ziele (InvokationList) aus dem Thread auf, aus dem es &amp;ldquo;gefeuert&amp;rdquo; wird. UI Controls, können i.A. nur im Mainthread arbeiten. Einen Zugriff aus einen anderen Thread führt zu einer Exception. Über das Interface ISynchronizedInvoke (implementiert von allen .</description></item><item><title>Tracing/Logging und die Config-Datei</title><link>https://www.alexander-koepke.de/post/2011-06-08-tracinglogging-config-file/</link><pubDate>Wed, 08 Jun 2011 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2011-06-08-tracinglogging-config-file/</guid><description>Logging von Informationen ist so gut wie in jedem Programm notwendig. Nicht alle Entwickler können oder wollen ein professionelles Log-Tool wie z.B. log4net oder nlog verwenden. In vielen Fällen reichen auch Debug.WriteLine oder Trace.WriteLine (letztes schreibt auch wenn die Software im Modus „Release“ kompiliert wurde).
Über eine Config-Datei lassen sich u.a. verschiedene TraceListener auswählen:
ConsoleTraceListener DefaultTraceListener DelimitedListTraceListener EventLogTraceListener EventSchemaTraceListener TextWriterTraceListener XmlWriterTraceListener eigene Implementierungen welche sich von TraceListener ableiten Damit kann man ohne neu kompilieren des Assemblies einfach den Ausgabeort des Trace-Informationen verändern.</description></item><item><title>Einiges über IDisposable</title><link>https://www.alexander-koepke.de/post/2011-06-07-something-idisposable/</link><pubDate>Tue, 07 Jun 2011 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2011-06-07-something-idisposable/</guid><description>Das Standard Interface IDisposable welches zur &amp;ldquo;Freigabe&amp;rdquo; von Ressourcen in .Net dient ist recht Einfach:
public interface IDisposable { void Dispose(); } Nur dieses Interface zu Implementieren reicht in vielen Fällen nicht aus. Es gibt z.B. einen FxCop Fehler Implement IDisposable correctly, dieser erscheint u.a. bei non-sealed Klassen welche keinen Medthode mit der Signatur protected virtual Dispose(bool) besitzen. IDisposable zu Implementieren wird nötig wenn man:
unmanged (native) Ressourcen lädt um diese wieder freizugeben managed Felder besitzt, welche wiederum IDisposable implementieren Im folgenden Beispiel zeigt eine (nach FxCop komplette Implementierung) einer Basis-Klasse und einer Kind-Klasse:</description></item></channel></rss>