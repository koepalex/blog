<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c-net on</title><link>https://koepalex.github.io/blog/categories/c-net/</link><description>Recent content in c-net on</description><generator>Hugo -- gohugo.io</generator><language>de-de</language><lastBuildDate>Thu, 14 Jul 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://koepalex.github.io/blog/categories/c-net/index.xml" rel="self" type="application/rss+xml"/><item><title>Zeit-Trennzeichen bei DateTime</title><link>https://koepalex.github.io/blog/post/2016-07-14-zeit-trennzeichen-bei-datetime/</link><pubDate>Thu, 14 Jul 2016 00:00:00 +0000</pubDate><guid>https://koepalex.github.io/blog/post/2016-07-14-zeit-trennzeichen-bei-datetime/</guid><description>Diese Woche hat es das .NET geschafft mich zu überraschen, ein Programm ist beim Kunden mit italienischen Windows immer wieder abgestürzt. Nach langem Suchen hat ein Kollege das Problem erkannt, was durch das folgende Beispiel veranschaulicht wird:
var ci = new CultureInfo(&amp;quot;it-IT&amp;quot;); var dateTime = DateTime.Now; var str = dateTime.ToString(&amp;quot;dd.mm.yyyy hh:mm:ss&amp;quot;, ci); Console.WriteLine(str); Ausgabe (.NET 3.5): 14.07.2016 20.45.30
Ausgabe (.NET 4.0): 14.07.2016 20:45:30
In der Ausgabe erkennt man, dass abhängig von der .</description></item><item><title>Performance Vortrag aus 2015</title><link>https://koepalex.github.io/blog/post/2016-06-13-performance-vortrag-aus-2015/</link><pubDate>Mon, 13 Jun 2016 00:00:00 +0000</pubDate><guid>https://koepalex.github.io/blog/post/2016-06-13-performance-vortrag-aus-2015/</guid><description>Letztes Jahr habe ich einen Vortrag zum Thema Performance gehalten, der Vermitteln sollte warum dieses Thema jeden (.NET-)Entwickler betrifft.
Nachdem ich mir jetzt die Zeit genommen habe um auch die Sprechernotizen aka &amp;ldquo;Tonspur&amp;rdquo; auf zuschreiben, konnte ich den Vortrag online stellen:
https://github.com/koepalex/performance_talk_2015
Vielleicht ist der Vortrag für jemanden Hilfreich :)</description></item><item><title>Debugging von Performance Problemen in .NET</title><link>https://koepalex.github.io/blog/post/2013-11-27-debugging-von-performance-problemen-in-net/</link><pubDate>Wed, 27 Nov 2013 00:00:00 +0000</pubDate><guid>https://koepalex.github.io/blog/post/2013-11-27-debugging-von-performance-problemen-in-net/</guid><description>Die Analyse von Speicherproblemen ist eine Aufgabe die bei großen .NET Anwendungen häufiger vorkommt. In C++ wurde gesucht, wer welche Speicherblöcke angefordert und nicht wieder freigegeben hat und im .NET Umfeld wird eben gesucht warum der Gabarge-Collector den Speicher nicht freigeben kann. Oder man sucht warum einige Benutzeraktionen besonders lange benötigen. Für die Analyse gibt es eine ganze Reihe guter kommerzieller Programme, auf diese möchte ich jedoch nicht eingehen, sondern ein paar kostenlosen Alternativen vorstellen.</description></item><item><title>Neues vom GC in .NET 4.0 und 4.5</title><link>https://koepalex.github.io/blog/post/2013-10-21-neues-vom-gc-in-net-4-0-und-4-5/</link><pubDate>Mon, 21 Oct 2013 00:00:00 +0000</pubDate><guid>https://koepalex.github.io/blog/post/2013-10-21-neues-vom-gc-in-net-4-0-und-4-5/</guid><description>Heute möchte ich etwas über Erneuerungen im .NET 4.0 / 4.5 sprechen. Das genannte bezieht sich auf den Workstation Garbage-Collector. Die Informationen für den Server Garbage-Collector entnehmen sie bitte den Links. Beginnen wir jedoch zunächst mit einer kurzen Auffrischung.
Wiederholung Das .NET Framework unterteilt seinen Heap in verschiedene Generationen.
In der Gen0 werden fast alle Objekte erstellt. Die Anfangsgröße beträgt rund 256KB. In der Gen1 werden Objekte gespeichert die eine Garbage-Collection überlebt haben.</description></item><item><title>GetHashCode dein Freund und Sorgenkind</title><link>https://koepalex.github.io/blog/post/2013-10-20-gethashcode-dein-freund-und-sorgenkind/</link><pubDate>Sun, 20 Oct 2013 00:00:00 +0000</pubDate><guid>https://koepalex.github.io/blog/post/2013-10-20-gethashcode-dein-freund-und-sorgenkind/</guid><description>Eine wichtige Methode beim Arbeiten im .NET Umfeld ist GetHashCode. Sie gibt einen 32 Bit Integer zurück der das Objekt identifizieren soll. Der Hash-Code beschreibt also die Identität des Objektes (im Gegensatz zur Speicherreferenz auf das Objekt).
Daraus leitet sich die Frage ab Wann zwei Objekte die selbe Identität besitzen? Im Falle einer Object-Relational-Mapper Klasse beispielsweise, wenn die Instanzen der O/R-Mapper Klasse auf ein und die selbe Zeile(n) der selben Tabelle(n) der selben Datenbank(en) verweisen.</description></item><item><title>Muss es immer die 100% Lösung sein?</title><link>https://koepalex.github.io/blog/post/2013-10-14-muss-es-immer-die-100-losung-sein/</link><pubDate>Mon, 14 Oct 2013 00:00:00 +0000</pubDate><guid>https://koepalex.github.io/blog/post/2013-10-14-muss-es-immer-die-100-losung-sein/</guid><description>Ich behaupte einfach mal, dass man sich in der Softwareentwicklung schnell in zu aufwendigen Lösungen verliert. Zumindest mir geht es regelmäßig so, ich habe einiges an Software entwickelt und Artikel geschrieben die nie veröffentlicht wurden (obwohl sie dafür gedacht waren). Der Grund für die nicht Veröffentlichung war, dass sie meiner Meinung nach nicht komplett waren oder meinen eigenen Ansprüchen nicht genügten.
Das soll nicht bedeutet das die Artikel zu schreiben oder die Software zu entwickeln Zeitverschwendung war.</description></item><item><title>Pipe aus eigenen Programmen nutzen</title><link>https://koepalex.github.io/blog/post/2013-10-13-pipe-aus-eigenen-programmen-nutzen/</link><pubDate>Sun, 13 Oct 2013 00:00:00 +0000</pubDate><guid>https://koepalex.github.io/blog/post/2013-10-13-pipe-aus-eigenen-programmen-nutzen/</guid><description>Mittels der von Unix Systemen bekannten Pipe (|) ist es auch unter Windows (via CMD-Line) möglich einzelne Kommandos zu verbinden. Die Pipe ermöglicht es die Ausgabe vom dem vorherigen Kommando direkt als Input des aktuellen Kommandos zu verwenden. Beispielsweise den Inhalt einer Datei einem Skript zu übergeben: type input.md | perl Markdown.pl &amp;gt; output.html
Logisch gesehen Ersetzt der Inhalt der Pipe ein einzelnes Konsolen-Argument. Um diese Funktionalität auch in den eigenen (Konsolen-) Programme verwenden zu können, sind im Allgemeinen nur zwei Erweiterungen notwendig.</description></item><item><title>Ermitteln des PID (Processidentifier) des Vaterprozesses</title><link>https://koepalex.github.io/blog/post/2012-10-14-ermitteln-des-pid-processidentifier-des-vaterprozesses/</link><pubDate>Sun, 14 Oct 2012 00:00:00 +0000</pubDate><guid>https://koepalex.github.io/blog/post/2012-10-14-ermitteln-des-pid-processidentifier-des-vaterprozesses/</guid><description>In manchen Fällen ist es notwendig heraus zu finden, welches der Vaterprozess eines Prozesses ist. Dafür gibt es im Allgemeinen drei verschiedene Lösungen im Windows .NET Umfeld.
Die häufigste Lösung ist die Verwendung von Performancecountern.
var process = FindProcess();
using (var pC = new PerformanceCounter(
&amp;ldquo;Process&amp;rdquo;,
&amp;ldquo;Creating Process ID&amp;rdquo;,
string.Format(&amp;quot;{0}#{1}&amp;quot;, process.ProcessName, 1), process.MachineName))
{
int pid = (int)pC.NextValue();
Console.WriteLine(&amp;ldquo;parent pid = {0}&amp;rdquo;, pid);
}
Die Verwendung von Performancecountern im Allgemeinen kann zwei mögliche Nachteile haben:</description></item><item><title>DSLs, Extension Methods und Fluent Interfaces</title><link>https://koepalex.github.io/blog/post/2012-07-28-dsls-extension-methods-und-fluent-interfaces/</link><pubDate>Sat, 28 Jul 2012 00:00:00 +0000</pubDate><guid>https://koepalex.github.io/blog/post/2012-07-28-dsls-extension-methods-und-fluent-interfaces/</guid><description>In den letzten Jahren wurde in der Softwareentwicklung viel über Domänenspezifische Sprachen (domain specific language, kurz: DSLs) geschrieben. DSLs sollen von einem Domänenexperten gelesen werden können, auch ohne das die Domänenexperten über Programmierkenntnisse verfügen. DSLs können auch Entwicklern helfen die Quelltexte leserlicher zu machen, sowie Fehler zu vermeiden. Die Quelltextzeile:
if (!SessionEstablished)
Ist einfach verständlich (für diejenigen welche eine C ähnliche Syntax verstehen), als Alternative könnte folgende Quelltextzeile dienen:
if (Not(SessionEstablished))</description></item><item><title>Testgetriebene Entwicklung (mit NCrunch)</title><link>https://koepalex.github.io/blog/post/2012-06-19-testgetriebene-entwicklung-mit-ncrunch/</link><pubDate>Tue, 19 Jun 2012 00:00:00 +0000</pubDate><guid>https://koepalex.github.io/blog/post/2012-06-19-testgetriebene-entwicklung-mit-ncrunch/</guid><description>Beim Testgetriebenen Entwickeln (TDD) wird ein Test-First-Ansatz verfolgt, dass bedeutet, dass erst der Test erstellt wird. Danach wird der Quelltext geschrieben, welcher notwendig ist, damit der Test erfolgreich durchläuft (umgangssprachlich: „grün wird“). Beim Entwickeln mittels TDD sollte nichts programmiert werden, was nicht durch einen Test vorher notwendig wird. Das führt zu einer hohen Abdeckung vom produktiven Quelltext mit Tests sowie zu einem testbaren Entwurf.
Die Vorteile sind u.a.
Dokumentation der Software (in den Test ist ersichtlich, wie die Klassen zu verwenden sind) Definierte Erwartungshaltung an die Implementierung (Refaktorisieren ist ohne Gefahr möglich, denn die Tests würden fehlschlagen, falls man etwas falsch gemacht hat).</description></item><item><title>Inversion Of Control(-Container), Service Locator und Dependency Injection</title><link>https://koepalex.github.io/blog/post/2012-06-08-inversion-of-control-container-service-locator-und-dependency-injection/</link><pubDate>Fri, 08 Jun 2012 00:00:00 +0000</pubDate><guid>https://koepalex.github.io/blog/post/2012-06-08-inversion-of-control-container-service-locator-und-dependency-injection/</guid><description>IOC-Container und DI sind zurzeit in vielen Fachzeitschriften diskutiert. Hier der Versuch einer kompakte Übersicht, die IOC, DI, SL und IOC-Container im Zusammenspiel erklärt.
Inversion Of Control
Beschreibt ein Paradigma zum Entwerfen von Frameworks. Ein Unterschied zwischen einem Framework und einer Bibliothek besteht darin, dass in einem Framework Methoden vom Verwender des Framework aufgerufen werden. Dies verändert den Kontrollfluss, bei einer klassischen Bibliothek, ruft der Verwender eine Methode auf, deren Funktionalität wird abgearbeitet und die Methode kehrt zum Aufrufer zurück.</description></item><item><title>FxCop Dispose von lokalen Variablen</title><link>https://koepalex.github.io/blog/post/2012-05-13-fxcop-dispose-von-lokalen-variablen/</link><pubDate>Sun, 13 May 2012 00:00:00 +0000</pubDate><guid>https://koepalex.github.io/blog/post/2012-05-13-fxcop-dispose-von-lokalen-variablen/</guid><description>Die Freigabe von Ressourcen (verwaltet und nativ) wird im .Net mittels Implementierung der IDisposable Schnittstelle (bzw. Anwendung des IDisposable Patterns realisiert). Der Aufruf der Dispose-Methode ist so wichtig, dass Microsoft spezielle FxCop Regeln implementiert hat (FxCop ist ein Tool zur statischen Analyse von .Net Assemblys). Die Regel „Disposable fields should be disposed“ (CA2213) besagt, dass eine Klasse welche Member enthält, die IDisposable implementieren, selber IDisposable implementieren soll. In der eigenen Dispose-Methode, werden dann die Dispose-Methoden der Members aufgerufen.</description></item><item><title>Vermeidung von switch-case zur Typen Bestimmung beim Aufruf von generischen Methoden</title><link>https://koepalex.github.io/blog/post/2012-04-20-vermeidung-von-switch-case-zur-typen-bestimmung-beim-aufruf-von-generischen-methoden-3/</link><pubDate>Fri, 20 Apr 2012 00:00:00 +0000</pubDate><guid>https://koepalex.github.io/blog/post/2012-04-20-vermeidung-von-switch-case-zur-typen-bestimmung-beim-aufruf-von-generischen-methoden-3/</guid><description>In der Entwicklung mit .NET hat man öfter folgendes Problem:
Methoden sind generisch implementiert und zu verwendende Objekte sind nur in Form von Referenzen auf Basistypen vorhanden (z.B. System.Array, System.Object). Diese Referenzen können nicht direkt an generische Methode übergeben werden (ergibt einen Compile Fehler).
Häufig liegen daher Typinformationen als String vor (über FullName-Property, aus Konfigurationsdatei, …). Diese Informationen werden anschließend verwendet, um den Typ der Referenz über switch-case aufzulösen.
Zum Beispiel:</description></item><item><title>UnauthorizedAccessException beim Kopieren einer Datei</title><link>https://koepalex.github.io/blog/post/2011-11-07-unauthorizedaccessexception-beim-kopieren-einer-datei/</link><pubDate>Mon, 07 Nov 2011 00:00:00 +0000</pubDate><guid>https://koepalex.github.io/blog/post/2011-11-07-unauthorizedaccessexception-beim-kopieren-einer-datei/</guid><description>Kopieren, verschieben, umbenennen und löschen von Dateien gehören zu häufigen Aufgaben eines Softwareentwicklers. In diesem Beitrag sollen ein paar Dinge aufgezeigt werden die einem beim kopieren von Datein vielleicht nicht bewusst sind. Wie kopiert man jetzt am besten eine Datei? Eine Variante ist die statische Methode der Klasse File:
File.Copy(@“C:\input\test.bmp“, @“C:\output\test.bmp“, true);
Damit man sich Überprüfungen wie ob die Datei bereits existiert (File.Exist()) sparen kann, wird die Überladung der Copy-Methode verwendet, welche bestehende Dateien überschreibt.</description></item><item><title>WPF Lern Videos</title><link>https://koepalex.github.io/blog/post/2011-07-10-wpf-lern-videos/</link><pubDate>Sun, 10 Jul 2011 00:00:00 +0000</pubDate><guid>https://koepalex.github.io/blog/post/2011-07-10-wpf-lern-videos/</guid><description>WPF (Windows Presentation Foundation) ist gerade wenn man vorher im System.Windows.Forms Umfeld gearbeitet hat, nicht leicht zu verstehen.
XAML-Beschreibungen, Code-Behind-Konzept, Routed Events, machen einem anfangs das Leben schwer. Um besser mit diesem Thema vertraut zu werden empfehle ich die Learning Videos von windowsclient.net.
Angesehen habe ich mir bis jetzt die Videos zum Thema 3D, Command Binding sowie Custom Commands diese fand ich klar Strukturiert und gut Erklärt.
Auch lernt man dadurch neue Tools kennen wie z.</description></item><item><title>WPF RichTextBox mit Durchgestrichenden Text</title><link>https://koepalex.github.io/blog/post/2011-06-18-wpf-richtextbox-mit-durchgestrichenden-text/</link><pubDate>Sat, 18 Jun 2011 00:00:00 +0000</pubDate><guid>https://koepalex.github.io/blog/post/2011-06-18-wpf-richtextbox-mit-durchgestrichenden-text/</guid><description>Um bei einer WPF RichTextBox einen Text Fett, Kursiv oder Unterstrichen darzustellen ist nicht viel notwenig. Eigentlich muss man im XAML nur einen (Toggle)Button definieren, der ein Kommando (EditingCommands) an die RichTextBox sendet:
Genauso einfach verhält es sich einen Text Hochgestellt oder Tiefgestellt darzustellen, mann muss nur zusätzlich noch die Schrift-Familie des Hinter der RichTextBox liegenden Dokumentes verändern:
Die Veränderungen an dem Text funktionieren in zwei Modi:
Ein Text wurde selektiert und der entsprechende Button geklickt, dies bewirkt das nur der selektierte Text beeinflusst wird.</description></item><item><title>Events über Threadgrenzen</title><link>https://koepalex.github.io/blog/post/2011-06-10-events-uber-threadgrenzen/</link><pubDate>Fri, 10 Jun 2011 00:00:00 +0000</pubDate><guid>https://koepalex.github.io/blog/post/2011-06-10-events-uber-threadgrenzen/</guid><description>Die meisten Tools/Programme verrichten Ihre Arbeit in Threads um die Oberfläche (UI) nicht zu blockieren. Eine &amp;ldquo;Kommunikations-Möglichkeit&amp;rdquo; um die UI beim Eintreten von bestimmten Gegebenheiten zu benachrichtigen sind Events. Ein Event im .Net ruft seine Ziele (InvokationList) aus dem Thread auf, aus dem es &amp;ldquo;gefeuert&amp;rdquo; wird. UI Controls, können i.A. nur im Mainthread arbeiten. Einen Zugriff aus einen anderen Thread führt zu einer Exception. Über das Interface ISynchronizedInvoke (implementiert von allen .</description></item><item><title>Tracing/Logging und die Config-Datei</title><link>https://koepalex.github.io/blog/post/2011-06-08-tracinglogging-config-file/</link><pubDate>Wed, 08 Jun 2011 00:00:00 +0000</pubDate><guid>https://koepalex.github.io/blog/post/2011-06-08-tracinglogging-config-file/</guid><description>Logging von Informationen ist so gut wie in jedem Programm notwendig. Nicht alle Entwickler können oder wollen ein professionelles Log-Tool wie z.B. log4net oder nlog verwenden. In vielen Fällen reichen auch Debug.WriteLine oder Trace.WriteLine (letztes schreibt auch wenn die Software im Modus „Release“ kompiliert wurde).
Über eine Config-Datei lassen sich u.a. verschiedene TraceListener auswählen:
ConsoleTraceListener DefaultTraceListener DelimitedListTraceListener EventLogTraceListener EventSchemaTraceListener TextWriterTraceListener XmlWriterTraceListener eigene Implementierungen welche sich von TraceListener ableiten Damit kann man ohne neu kompilieren des Assemblies einfach den Ausgabeort des Trace-Informationen verändern.</description></item><item><title>Einiges über IDisposable</title><link>https://koepalex.github.io/blog/post/2011-06-07-something-idisposable/</link><pubDate>Tue, 07 Jun 2011 00:00:00 +0000</pubDate><guid>https://koepalex.github.io/blog/post/2011-06-07-something-idisposable/</guid><description>Das Standard Interface IDisposable welches zur &amp;ldquo;Freigabe&amp;rdquo; von Ressourcen in .Net dient ist recht Einfach:
public interface IDisposable { void Dispose(); }
Nur dieses Interface zu Implementieren reicht in vielen Fällen nicht aus. Es gibt z.B. einen FxCop Fehler Implement IDisposable correctly, dieser erscheint u.a. bei non-sealed Klassen welche keinen Medthode mit der Signatur protected virtual Dispose(bool) besitzen. IDisposable zu Implementieren wird nötig wenn man:
unmanged (native) Ressourcen lädt um diese wieder freizugeben managed Felder besitzt, welche wiederum IDisposable implementieren Im folgenden Beispiel zeigt eine (nach FxCop komplette Implementierung) einer Basis-Klasse und einer Kind-Klasse:</description></item></channel></rss>