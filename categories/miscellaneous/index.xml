<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Miscellaneous on</title><link>https://www.alexander-koepke.de/categories/miscellaneous/</link><description>Recent content in Miscellaneous on</description><generator>Hugo</generator><language>de-de</language><lastBuildDate>Sun, 05 Jan 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://www.alexander-koepke.de/categories/miscellaneous/index.xml" rel="self" type="application/rss+xml"/><item><title>AutoHotkey</title><link>https://www.alexander-koepke.de/post/2014-01-05-autohotkey/</link><pubDate>Sun, 05 Jan 2014 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2014-01-05-autohotkey/</guid><description>&lt;p>Durch Scott Hanselman’s Blog Artikel &lt;a href="http://www.hanselman.com/blog/ScottHanselmans2014UltimateDeveloperAndPowerUsersToolListForWindows.aspx">2014 Ultimate Developer and Power Users Tool List for Windows&lt;/a>. bin ich auf &lt;strong>&lt;a href="http://www.autohotkey.com">AutoHotkey&lt;/a>&lt;/strong> aufmerksam geworden. Es biete wie AppleScript unter Mac OS X, die Möglichkeit verschiedene (lästige) Aufgaben zu automatisieren bzw. Programme um Funktionalitäten zu erweitern.&lt;/p>
&lt;hr>
&lt;p>Damit könnte man zum Beispiel einen beliebiges Programm mit einer Eingabemaske um &lt;em>Snippets&lt;/em> erweitern. Als Besonderheit können AutoHotkey-Skript auch in eine ausführbare Datei kompiliert werden und somit auf Rechnern ohne AutoHotkey verwendet werden.&lt;/p></description></item><item><title>Muss es immer die 100% Lösung sein?</title><link>https://www.alexander-koepke.de/post/2013-10-14-muss-es-immer-die-100-losung-sein/</link><pubDate>Mon, 14 Oct 2013 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2013-10-14-muss-es-immer-die-100-losung-sein/</guid><description>&lt;p>Ich behaupte einfach mal, dass man sich in der Softwareentwicklung schnell in zu aufwendigen Lösungen verliert. Zumindest mir geht es regelmäßig so, ich habe einiges an Software entwickelt und Artikel geschrieben die nie veröffentlicht wurden (obwohl sie dafür gedacht waren). Der Grund für die nicht Veröffentlichung war, dass sie meiner Meinung nach nicht komplett waren oder meinen eigenen Ansprüchen nicht genügten.&lt;/p>
&lt;p>Das soll nicht bedeutet das die Artikel zu schreiben oder die Software zu entwickeln Zeitverschwendung war. Ganz im Gegenteil es ist immer beeindruckend wie viel man lernen kann, sobald man sich mit etwas anderen beschäftigt als den Arbeitsthemen. Die dabei gewonnenen Erkenntnisse sind, vielleicht auch für andere Interessant (ist schon ab und zu vorgekommen &lt;em>;)&lt;/em>). Daher resultiert für mich die Frage &lt;strong>Muss es immer die 100% Lösung sein?&lt;/strong> wobei die simple Antwort &lt;strong>Nein&lt;/strong> ist. Um Unklarheiten vorzubeugen damit ist nicht gemeint, dass man nur 80% der Anforderungen erfüllen soll. Vielmehr geht es um Erkenntnisaustausch/-gewinn.&lt;/p></description></item><item><title>Eindruck und Gedanken zu Mac OS X</title><link>https://www.alexander-koepke.de/post/2013-08-24-eindruck-und-gedanken-zu-mac-os-x/</link><pubDate>Sat, 24 Aug 2013 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2013-08-24-eindruck-und-gedanken-zu-mac-os-x/</guid><description>&lt;p>Durch den Wunsch ein neues Notebook zu kaufen, stand ich vor der Wahl Linux, Windows oder Mac OS X. Da ich auf Arbeit Windows einsetze und früher in meiner Freizeit viel mit Linux (Ubuntu, Debian,  Linux Mint, Fedora) bzw. BSD (FreeBSD) gearbeitet habe ist die Wahl des Betriebssystems auf Mac OS X gefallen. Und die Wahl der Hardware auf ein Mac Book Pro 13,3&amp;quot; gefallen. Ich gebe zu das es mich immer interessiert hat zu Erfahren, warum Niemanden den ich kenne, sein Mac OS X Gerät missen möchte. In diesem Beitrag werde ich etwas über meinen Ersten Eindruck erzählen.&lt;/p></description></item><item><title>Immutable Objects am Beispiel von Passwort Hantierung in Java</title><link>https://www.alexander-koepke.de/post/2013-03-02-immutable-objects-am-beispiel-von-passwort-hantierung-in-java/</link><pubDate>Sat, 02 Mar 2013 00:00:00 +0000</pubDate><guid>https://www.alexander-koepke.de/post/2013-03-02-immutable-objects-am-beispiel-von-passwort-hantierung-in-java/</guid><description>&lt;p>In Java sind Strings „Immutable Objects“ (unveränderliche Objekte),&lt;br>
dass bedeutet sie werden zur Laufzeit nicht mehr geändert.  Immutables Objects haben viele Vorteile:&lt;/p>
&lt;ul>
&lt;li>im Allgemeinen ist es einfach möglich zu parallelisieren&lt;/li>
&lt;li>Implementierung von Undo- und Redo-Funktionalitäten sind normalerweise einfach (z.B. mittels Memento-Pattern)&lt;/li>
&lt;li>James Gosling (einer der Erfinder von Java), gibt zusätzlich an, dass bei Immutable Objects es grundsätzlich möglich ist, Ergebnisse zu Cachen und das die Sicherheit wird erhöht. (vgl. &lt;a href="https://www.artima.com/intv/gosling313.html">https://www.artima.com/intv/gosling313.html&lt;/a> )&lt;/li>
&lt;/ul>
&lt;p>Sicherheit ist ein gutes Stichwort, denn Immutable Objects können auch Sicherheitsprobleme mit sich bringen. Schauen wir uns einmal Passwörter bei Java an. Diese sollten niemals in einem String gespeichert werden, da sie solange der String im Speicher existiert, im Klartext im Speicher stehen. Die allgemeine Empfehlung in verschiedenen Security Guides lautet daher Passwörter nur als Char-Array zu hantieren und sobald man das Passwort nicht mehr benötigt, den Inhalt dieses Array zu überschreiben. Überschreiben funktioniert mit Immutable Objects nicht, was ein Passwort in einem String zu einem Sicherheitsrisiko werden lässt.&lt;/p></description></item></channel></rss>